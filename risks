#!/usr/bin/env zsh

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
risks_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks - Identity creation and management tool\n"
    echo

  else
    printf "risks - Identity creation and management tool\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks [OPTIONS] COMMAND\n"
  printf "  risks [COMMAND] --help | -h\n"
  printf "  risks --version\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Format or manage the hush partition mount points and read/write permissions\n" "$(green "hush")    "
  printf "  %s   Create, manage, restore or use backup devices and partitions\n" "$(green "backup")  "
  printf "  %s   Create, use and manage identities\n" "$(green "identity")"
  printf "  %s   Manage GPG coffings, keys, passwords and settings\n" "$(green "gpg")     "
  printf "  %s   Manage SSH-related credentials and settings\n" "$(green "ssh")     "
  printf "  %s   Create, use and manage tombs (stores)\n" "$(green "tomb")    "
  printf "  %s   Show currently open data stores\n" "$(green "list")    "
  printf "  %s   Close all active identities and unmount hush/backup partitions\n" "$(green "slam")    "
  printf "  %s   Close any open identity, and wipe all files and directories that should not exist.\n" "$(green "cleanup") "
  printf "  %s   Copy some resource to a VM where to use it (completed)\n" "$(green "load")    "
  printf "  %s   Move some data coming from another VM to a (tomb) directory\n" "$(green "save")    "
  printf "  %s   Retrieve the encrypted names of identity files\n" "$(green "resolve") "
  printf "  %s   Manage the risk global configuration\n" "$(green "config")  "
  printf "  %s   Manage the small key=value store used by other commands/functions\n" "$(green "kv")      "
  printf "  %s   Show help about a command\n" "$(green "help")    "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--verbose, -v"
    printf "    Show verbose logging\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
risks_hush_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks hush - Format or manage the hush partition mount points and read/write permissions\n"
    echo

  else
    printf "risks hush - Format or manage the hush partition mount points and read/write permissions\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks hush COMMAND\n"
  printf "  risks hush [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Format a drive for storing identity secrets (GPG/coffin/age keys)\n" "$(green "format")"
  printf "  %s   Mount the hush drive\n" "$(green "mount") "
  printf "  %s   Set read-write permissions on the hush partition\n" "$(green "rw")    "
  printf "  %s   Set read-only permissions on the hush partition\n" "$(green "ro")    "
  printf "  %s   Unmount the hush drive\n" "$(green "umount")"
  printf "  %s   Print the status of the hush device (mount points, etc)\n" "$(green "status")"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_hush_format_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks hush format - Format a drive for storing identity secrets (GPG/coffin/age keys)\n"
    echo

  else
    printf "risks hush format - Format a drive for storing identity secrets (GPG/coffin/age keys)\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks hush format DEVICE [OPTIONS]\n"
  printf "  risks hush format --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--size-percent, -P PERCENT"
    printf "    Size of encrypted partition, as a percentage of the entire drive\n"
    printf "    Default: 90\n"
    echo

    # :flag.usage
    printf "  %s\n" "--size-absolute, -A SIZE"
    printf "    Size of encrypted partition, in absolute terms, WITH unit (eg. 100G, 20M,\n    etc)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "DEVICE")"
    printf "    Device file of the sdcard drive (must be a whole drive without a partition\n    number, eg. /dev/sda)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  hush format --size-absolute 200M /dev/xvdi   # The encrypted part will be 200M\n  in size\n"
    printf "  hush format --size-percent 70 /dev/xvdi      # The encrypted part takes 70% of\n  the drive\n"
    echo

  fi
}

# :command.usage
risks_hush_mount_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks hush mount - Mount the hush drive\n"
    echo

  else
    printf "risks hush mount - Mount the hush drive\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks hush mount\n"
  printf "  risks hush mount --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_hush_rw_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks hush rw - Set read-write permissions on the hush partition\n"
    echo

  else
    printf "risks hush rw - Set read-write permissions on the hush partition\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks hush rw\n"
  printf "  risks hush rw --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_hush_ro_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks hush ro - Set read-only permissions on the hush partition\n"
    echo

  else
    printf "risks hush ro - Set read-only permissions on the hush partition\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks hush ro\n"
  printf "  risks hush ro --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_hush_umount_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks hush umount - Unmount the hush drive\n"
    echo

  else
    printf "risks hush umount - Unmount the hush drive\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks hush umount\n"
  printf "  risks hush umount --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_hush_status_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks hush status - Print the status of the hush device (mount points, etc)\n"
    echo

  else
    printf "risks hush status - Print the status of the hush device (mount points, etc)\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks hush status\n"
  printf "  risks hush status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_backup_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks backup - Create, manage, restore or use backup devices and partitions\n"
    echo

  else
    printf "risks backup - Create, manage, restore or use backup devices and partitions\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks backup COMMAND\n"
  printf "  risks backup [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Format and setup a drive for as a risks backup medium\n" "$(green "format")  "
  printf "  %s   Mount the backup partition/device\n" "$(green "mount")   "
  printf "  %s   Unmount the current backup drive\n" "$(green "umount")  "
  printf "  %s   Unlock encryption on the backup of an identity\n" "$(green "unlock")  "
  printf "  %s   Lock encryption on the backup of an identity\n" "$(green "lock")    "
  printf "  %s   Print the status of the backup (mount points, locks, etc)\n" "$(green "status")  "
  printf "  %s   Backup the graveyard and the GPG coffin file for the current identity, active or specified.\n" "$(green "identity")"
  printf "  %s   Backup only the raw hush device image\n" "$(green "hush")    "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_backup_format_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks backup format - Format and setup a drive for as a risks backup medium\n"
    echo

  else
    printf "risks backup format - Format and setup a drive for as a risks backup medium\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks backup format DEVICE\n"
  printf "  risks backup format --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "DEVICE")"
    printf "    Device file of the backup drive (must be a whole drive without a partition\n    number, eg. /dev/sdb)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  backup format /dev/xvdi\n"
    echo

  fi
}

# :command.usage
risks_backup_mount_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks backup mount - Mount the backup partition/device\n"
    echo

  else
    printf "risks backup mount - Mount the backup partition/device\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks backup mount DEVICE\n"
  printf "  risks backup mount --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "DEVICE")"
    printf "    Device file of the backup drive (must be a whole drive without a partition\n    number, eg. /dev/sdb)\n"
    echo

  fi
}

# :command.usage
risks_backup_umount_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks backup umount - Unmount the current backup drive\n"
    echo

  else
    printf "risks backup umount - Unmount the current backup drive\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks backup umount\n"
  printf "  risks backup umount --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_backup_unlock_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks backup unlock - Unlock encryption on the backup of an identity\n"
    echo

  else
    printf "risks backup unlock - Unlock encryption on the backup of an identity\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks backup unlock IDENTITY\n"
  printf "  risks backup unlock --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity owning the backup.\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  backup unlock john_doe\n"
    echo

  fi
}

# :command.usage
risks_backup_lock_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks backup lock - Lock encryption on the backup of an identity\n"
    echo

  else
    printf "risks backup lock - Lock encryption on the backup of an identity\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks backup lock\n"
  printf "  risks backup lock --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_backup_status_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks backup status - Print the status of the backup (mount points, locks, etc)\n"
    echo

  else
    printf "risks backup status - Print the status of the backup (mount points, locks, etc)\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks backup status\n"
  printf "  risks backup status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_backup_identity_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks backup identity - Backup the graveyard and the GPG coffin file for the current identity, active or specified.\n"
    echo

  else
    printf "risks backup identity - Backup the graveyard and the GPG coffin file for the current identity, active or specified.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks backup identity [IDENTITY] [OPTIONS]\n"
  printf "  risks backup identity --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--log-file, -f LOGFILE"
    printf "    Path to log file, defaults to ~/.graveyard/<identity>.log\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Name of identity to backup. (Current identity if not specified)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  backup identity john_doe\n"
    printf "  backup identity\n"
    echo

  fi
}

# :command.usage
risks_backup_hush_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks backup hush - Backup only the raw hush device image\n"
    echo

  else
    printf "risks backup hush - Backup only the raw hush device image\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks backup hush\n"
  printf "  risks backup hush --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_identity_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks identity - Create, use and manage identities\n"
    echo

  else
    printf "risks identity - Create, use and manage identities\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks identity COMMAND\n"
  printf "  risks identity [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Create a new GPG identity, with SSH/password-store/management and associated tombs\n" "$(green "create")"
  printf "  %s   Open an identity GPG keyring and builtin tomb stores (SSH/pass/mgmt)\n" "$(green "open")  "
  printf "  %s   Close all open tombs and GPG keyring of the active identity\n" "$(green "close") "
  printf "  %s   Delete an identity GPG keyring, tomb stores and backup\n" "$(green "delete")"
  printf "  %s   Backup identity graveyard and GPG coffin (alias for 'risks backup identity').\n" "$(green "backup")"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_identity_create_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks identity create - Create a new GPG identity, with SSH/password-store/management and associated tombs\n"
    echo

  else
    printf "risks identity create - Create a new GPG identity, with SSH/password-store/management and associated tombs\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks identity create [NAME] [EMAIL] [EXPIRY_DATE] [OPTIONS]\n"
  printf "  risks identity create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--backup, -b"
    printf "    Device file of the backup drive (must be a whole drive without a partition\n    number, eg. /dev/sdb)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--burner, -B"
    printf "    Generate a random username, and only generate GPG/Pass stores\n"
    echo

    # :flag.usage
    printf "  %s\n" "--mail, -m"
    printf "    Mail provider to use for the GPG key (appended to the name when no full mail\n    is given as arg)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "NAME")"
    printf "    Alias/nym/name to use for the identity (use quotes if spaces) (optional if\n    --burner is used)\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "EMAIL")"
    printf "    Email address to use for the GPG identity (optional, can also use --mail)\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "EXPIRY_DATE")"
    printf "    Human readable, or GPG-compliant expiry duration to use for the GPG subkeys\n    (eg. '1 year', '1 week', etc)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  identity create 'John Doe' john.doe@mail.com '1 year' --backup /dev/xvdj\n"
    printf "  identity create --burner --mail proton.me\n"
    printf "  identity create 'James Steel' jamessteel@proton.me --burner\n"
    echo

  fi
}

# :command.usage
risks_identity_open_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks identity open - Open an identity GPG keyring and builtin tomb stores (SSH/pass/mgmt)\n"
    echo

  else
    printf "risks identity open - Open an identity GPG keyring and builtin tomb stores (SSH/pass/mgmt)\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks identity open IDENTITY\n"
  printf "  risks identity open --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity to open\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  identity open john_doe       # Opens gpg coffin and mgmt/pass/ssh/signal tombs\n"
    echo

  fi
}

# :command.usage
risks_identity_close_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks identity close - Close all open tombs and GPG keyring of the active identity\n"
    echo

  else
    printf "risks identity close - Close all open tombs and GPG keyring of the active identity\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks identity close [IDENTITY]\n"
  printf "  risks identity close --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity to close (optional if an identity is active).\n"
    echo

  fi
}

# :command.usage
risks_identity_delete_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks identity delete - Delete an identity GPG keyring, tomb stores and backup\n"
    echo

  else
    printf "risks identity delete - Delete an identity GPG keyring, tomb stores and backup\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks identity delete NAME [OPTIONS]\n"
  printf "  risks identity delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--backup, -b"
    printf "    If a backup device is mounted, also delete all the associated backup data\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "NAME")"
    printf "    Name of identity to delete\n"
    echo

  fi
}

# :command.usage
risks_identity_backup_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks identity backup - Backup identity graveyard and GPG coffin (alias for 'risks backup identity').\n"
    echo

  else
    printf "risks identity backup - Backup identity graveyard and GPG coffin (alias for 'risks backup identity').\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks identity backup [IDENTITY]\n"
  printf "  risks identity backup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Name of identity to backup. (Current identity if not specified)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  identity backup john_doe\n"
    printf "  identity backup\n"
    echo

  fi
}

# :command.usage
risks_identity_active_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks identity active - Prints the active identity as a raw string, to be used by prompts.\n"
    echo

  else
    printf "risks identity active - Prints the active identity as a raw string, to be used by prompts.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks identity active\n"
  printf "  risks identity active --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_gpg_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks gpg - Manage GPG coffings, keys, passwords and settings\n"
    echo

  else
    printf "risks gpg - Manage GPG coffings, keys, passwords and settings\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks gpg COMMAND\n"
  printf "  risks gpg [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Generate a new GPG subkey and add it to the keyring\n" "$(green "generate")"
  printf "  %s   Open the GPG keyring of an identity\n" "$(green "open")    "
  printf "  %s   Close the active identity GPG keyring\n" "$(green "close")   "
  printf "  %s   Import the GPG private key from the backup to the GPG keyring, in read-write mode\n" "$(green "import")  "
  printf "  %s   Remove the GPG private key from the keyring, and set the hush in read-only mode\n" "$(green "remove")  "
  printf "  %s   Copy the identity GPG passphrase to the clipboard\n" "$(green "pass")    "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_gpg_generate_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks gpg generate - Generate a new GPG subkey and add it to the keyring\n"
    echo

  else
    printf "risks gpg generate - Generate a new GPG subkey and add it to the keyring\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks gpg generate [ALGO] [OPTIONS]\n"
  printf "  risks gpg generate --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--sign, -S"
    printf "    If generated key is a GPG subkey, add sign capability\n"
    echo

    # :flag.usage
    printf "  %s\n" "--encrypt, -E"
    printf "    If generated key is a GPG subkey, add encrypt capability\n"
    echo

    # :flag.usage
    printf "  %s\n" "--interactive, -i"
    printf "    Start the GPG key creation prompt\n"
    echo

    # :flag.usage
    printf "  %s\n" "--expert, -e"
    printf "    If --interactive is used, start the GPG prompt in expert mode\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "ALGO")"
    printf "    Key algorithm\n"
    echo

  fi
}

# :command.usage
risks_gpg_open_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks gpg open - Open the GPG keyring of an identity\n"
    echo

  else
    printf "risks gpg open - Open the GPG keyring of an identity\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks gpg open IDENTITY\n"
  printf "  risks gpg open --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity owning the GPG keyring.\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  gpg open john_doe            # Opens the GPG keyring for identity 'john_doe'\n"
    echo

  fi
}

# :command.usage
risks_gpg_close_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks gpg close - Close the active identity GPG keyring\n"
    echo

  else
    printf "risks gpg close - Close the active identity GPG keyring\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks gpg close [IDENTITY]\n"
  printf "  risks gpg close --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity owning the GPG keyring (optional).\n"
    echo

  fi
}

# :command.usage
risks_gpg_import_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks gpg import - Import the GPG private key from the backup to the GPG keyring, in read-write mode\n"
    echo

  else
    printf "risks gpg import - Import the GPG private key from the backup to the GPG keyring, in read-write mode\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks gpg import IDENTITY\n"
  printf "  risks gpg import --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity owning the backup.\n"
    echo

  fi
}

# :command.usage
risks_gpg_remove_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks gpg remove - Remove the GPG private key from the keyring, and set the hush in read-only mode\n"
    echo

  else
    printf "risks gpg remove - Remove the GPG private key from the keyring, and set the hush in read-only mode\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks gpg remove\n"
  printf "  risks gpg remove --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_gpg_pass_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks gpg pass - Copy the identity GPG passphrase to the clipboard\n"
    echo

  else
    printf "risks gpg pass - Copy the identity GPG passphrase to the clipboard\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks gpg pass [IDENTITY] [OPTIONS]\n"
  printf "  risks gpg pass --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--timeout, -t TIMEOUT"
    printf "    Clear the clipboard after this many seconds\n"
    printf "    Default: 45\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity for which to copy the GPG passphrase. Optional if an identity is\n    active.\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  gpgpass john_doe         # Copy john_doe's GPG key passphrase\n"
    printf "  gpgpass                  # Copy the current identity's GPG key passphrase\n"
    echo

  fi
}

# :command.usage
risks_ssh_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks ssh - Manage SSH-related credentials and settings\n"
    echo

  else
    printf "risks ssh - Manage SSH-related credentials and settings\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks ssh COMMAND\n"
  printf "  risks ssh [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Generate a new SSH key and add it to the keyring\n" "$(green "generate")"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_ssh_generate_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks ssh generate - Generate a new SSH key and add it to the keyring\n"
    echo

  else
    printf "risks ssh generate - Generate a new SSH key and add it to the keyring\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks ssh generate [ALGO] [OPTIONS]\n"
  printf "  risks ssh generate --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--bits, -b"
    printf "    Key size in bits\n"
    echo

    # :flag.usage
    printf "  %s\n" "--filename, -f"
    printf "    Specify a filename for the generated keys (overrides the default generated:\n    <identity>-<algo>-<rand_number>)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "ALGO")"
    printf "    Key algorithm\n"
    echo

  fi
}

# :command.usage
risks_tomb_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks tomb - Create, use and manage tombs (stores)\n"
    echo

  else
    printf "risks tomb - Create, use and manage tombs (stores)\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks tomb COMMAND\n"
  printf "  risks tomb [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Create a new tomb\n" "$(green "create")"
  printf "  %s   Open an identity tomb\n" "$(green "open")  "
  printf "  %s   Close an identity tomb\n" "$(green "close") "
  printf "  %s   Delete an identity tomb, and optionally its backup\n" "$(green "delete")"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_tomb_create_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks tomb create - Create a new tomb\n"
    echo

  else
    printf "risks tomb create - Create a new tomb\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks tomb create TOMB_NAME SIZE [IDENTITY]\n"
  printf "  risks tomb create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "TOMB_NAME")"
    printf "    Name/label to use for the tomb\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "SIZE")"
    printf "    Size (in MB) of the tomb\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity for which to create the tomb. (optional if an identity is active\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  tomb create Data 100 john_doe\n"
    echo

  fi
}

# :command.usage
risks_tomb_open_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks tomb open - Open an identity tomb\n"
    echo

  else
    printf "risks tomb open - Open an identity tomb\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks tomb open RESOURCE [IDENTITY]\n"
  printf "  risks tomb open --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "RESOURCE")"
    printf "    Datastore (tomb) or full identity (coffin/GPG/SSH,etc) to open\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity owning the store. (optional if an identity is active).\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  tomb open gpg john_doe            # Opens the GPG keyring for identity\n  'john_doe'\n"
    printf "  tomb open ssh                     # Opens the ssh tomb for the active identity\n"
    printf "  tomb open pass [identity]         # Opens the password-store for active\n  identity\n"
    echo

  fi
}

# :command.usage
risks_tomb_close_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks tomb close - Close an identity tomb\n"
    echo

  else
    printf "risks tomb close - Close an identity tomb\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks tomb close RESOURCE [IDENTITY]\n"
  printf "  risks tomb close --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "RESOURCE")"
    printf "    Datastore (tomb) or full identity (coffin/GPG/SSH,etc) to close\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity owning the store. (optional if an identity is active).\n"
    echo

  fi
}

# :command.usage
risks_tomb_delete_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks tomb delete - Delete an identity tomb, and optionally its backup\n"
    echo

  else
    printf "risks tomb delete - Delete an identity tomb, and optionally its backup\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks tomb delete TOMB_NAME [OPTIONS]\n"
  printf "  risks tomb delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--backup, -b"
    printf "    If a backup device is mounted, also delete all the associated backup data\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "TOMB_NAME")"
    printf "    Name/label of the tomb to delete\n"
    echo

  fi
}

# :command.usage
risks_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks list - Show currently open data stores\n"
    echo

  else
    printf "risks list - Show currently open data stores\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks list [RESOURCE]\n"
  printf "  risks list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "RESOURCE")"
    printf "    Datastore types to list (all if not provided)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  list coffins         # Lists open GPG coffins\n"
    printf "  list tombs           # Lists open tombs\n"
    echo

  fi
}

# :command.usage
risks_slam_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks slam - Close all active identities and unmount hush/backup partitions\n"
    echo

  else
    printf "risks slam - Close all active identities and unmount hush/backup partitions\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks slam\n"
  printf "  risks slam --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_cleanup_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks cleanup - Close any open identity, and wipe all files and directories that should not exist.\n"
    echo

  else
    printf "risks cleanup - Close any open identity, and wipe all files and directories that should not exist.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks cleanup\n"
  printf "  risks cleanup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_load_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks load - Copy some resource to a VM where to use it (completed)\n"
    echo

  else
    printf "risks load - Copy some resource to a VM where to use it (completed)\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks load RESOURCE DEST_VM [IDENTITY] [OPTIONS]\n"
  printf "  risks load --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--close-tomb, -c"
    printf "    Immediately close the tomb after sending the files\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "RESOURCE")"
    printf "    Name of a tomb containing the data to be transfered. The tomb will be opened\n    if needed\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "DEST_VM")"
    printf "    Destination VM\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity owning the tomb (optional if an identity is active)\n"
    echo

  fi
}

# :command.usage
risks_save_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks save - Move some data coming from another VM to a (tomb) directory\n"
    echo

  else
    printf "risks save - Move some data coming from another VM to a (tomb) directory\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks save SOURCE_VM RESOURCE [IDENTITY] [OPTIONS]\n"
  printf "  risks save --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--close-tomb, -c"
    printf "    Immediately close the tomb after saving the files\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "SOURCE_VM")"
    printf "    Source VM, which has an equivalent directory in ~/QubesIncoming/\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "RESOURCE")"
    printf "    Name of a tomb containing the data to be transfered. The tomb will be opened\n    if needed\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    Identity owning the tomb (optional if an identity is active)\n"
    echo

  fi
}

# :command.usage
risks_resolve_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks resolve - Retrieve the encrypted names of identity files\n"
    echo

  else
    printf "risks resolve - Retrieve the encrypted names of identity files\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks resolve COMMAND\n"
  printf "  risks resolve [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Get the name of the gpg coffin for an identity\n" "$(green "coffin")"
  printf "  %s   Get the filename of a tomb file\n" "$(green "tomb")  "
  printf "  %s   Get the filename of a tomb key\n" "$(green "key")   "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_resolve_coffin_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks resolve coffin - Get the name of the gpg coffin for an identity\n"
    echo

  else
    printf "risks resolve coffin - Get the name of the gpg coffin for an identity\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks resolve coffin [NAME]\n"
  printf "  risks resolve coffin --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "NAME")"
    printf "    identity name\n"
    echo

  fi
}

# :command.usage
risks_resolve_tomb_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks resolve tomb - Get the filename of a tomb file\n"
    echo

  else
    printf "risks resolve tomb - Get the filename of a tomb file\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks resolve tomb TOMB_NAME [IDENTITY]\n"
  printf "  risks resolve tomb --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "TOMB_NAME")"
    printf "    Tomb name\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    identity name (optional)\n"
    echo

  fi
}

# :command.usage
risks_resolve_key_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks resolve key - Get the filename of a tomb key\n"
    echo

  else
    printf "risks resolve key - Get the filename of a tomb key\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks resolve key TOMB_NAME [IDENTITY]\n"
  printf "  risks resolve key --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "TOMB_NAME")"
    printf "    Tomb name\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "IDENTITY")"
    printf "    identity name (optional)\n"
    echo

  fi
}

# :command.usage
risks_config_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks config - Manage the risk global configuration\n"
    echo

  else
    printf "risks config - Manage the risk global configuration\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks config COMMAND\n"
  printf "  risks config [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Set a configuration variable to a value\n" "$(green "set")  "
  printf "  %s   Print the value of a configuration variable\n" "$(green "get")  "
  printf "  %s   Delete the value of a configuration variable\n" "$(green "unset")"
  printf "  %s   List all configuration variables\n" "$(green "list") "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_config_set_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks config set - Set a configuration variable to a value\n"
    echo

  else
    printf "risks config set - Set a configuration variable to a value\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks config set KEY VALUE\n"
  printf "  risks config set --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "KEY")"
    printf "    Name of of key to set\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "VALUE")"
    printf "    Value to assign to the key\n"
    echo

  fi
}

# :command.usage
risks_config_get_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks config get - Print the value of a configuration variable\n"
    echo

  else
    printf "risks config get - Print the value of a configuration variable\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks config get KEY\n"
  printf "  risks config get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "KEY")"
    printf "    Name of of key to show\n"
    echo

  fi
}

# :command.usage
risks_config_unset_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks config unset - Delete the value of a configuration variable\n"
    echo

  else
    printf "risks config unset - Delete the value of a configuration variable\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks config unset KEY\n"
  printf "  risks config unset --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "KEY")"
    printf "    Name of of key to delete/unset\n"
    echo

  fi
}

# :command.usage
risks_config_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks config list - List all configuration variables\n"
    echo

  else
    printf "risks config list - List all configuration variables\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks config list\n"
  printf "  risks config list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_config_keys_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks config keys - List all configuration variables as an array (for completions)\n"
    echo

  else
    printf "risks config keys - List all configuration variables as an array (for completions)\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks config keys\n"
  printf "  risks config keys --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_kv_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks kv - Manage the small key=value store used by other commands/functions\n"
    echo

  else
    printf "risks kv - Manage the small key=value store used by other commands/functions\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks kv COMMAND\n"
  printf "  risks kv [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Set a variable to a value\n" "$(green "set")  "
  printf "  %s   Get the value of a variable\n" "$(green "get")  "
  printf "  %s   Unset an existing variable\n" "$(green "unset")"
  printf "  %s   List all key=value pairs in the store\n" "$(green "list") "
  printf "  %s   Delete all key=value pairs in the store\n" "$(green "clean")"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_kv_set_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks kv set - Set a variable to a value\n"
    echo

  else
    printf "risks kv set - Set a variable to a value\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks kv set KEY VALUE\n"
  printf "  risks kv set --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "KEY")"
    printf "    Name of of key to set\n"
    echo

    # :argument.usage
    printf "  %s\n" "$(blue "VALUE")"
    printf "    Value to assign to the key\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  set signalVM MySignalVM      # Sets the key 'signalVM' to 'mySignalVM' in the\n  store\n"
    echo

  fi
}

# :command.usage
risks_kv_get_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks kv get - Get the value of a variable\n"
    echo

  else
    printf "risks kv get - Get the value of a variable\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks kv get KEY\n"
  printf "  risks kv get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "KEY")"
    printf "    Name of of key to show\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  get signalVM              # Prints the value of the key 'signalVM'\n"
    echo

  fi
}

# :command.usage
risks_kv_unset_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks kv unset - Unset an existing variable\n"
    echo

  else
    printf "risks kv unset - Unset an existing variable\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks kv unset KEY\n"
  printf "  risks kv unset --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "KEY")"
    printf "    Name of of key to delete/unset\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  unset signalVM            # Deletes the key 'signalVM' in the key-value store\n"
    echo

  fi
}

# :command.usage
risks_kv_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks kv list - List all key=value pairs in the store\n"
    echo

  else
    printf "risks kv list - List all key=value pairs in the store\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks kv list\n"
  printf "  risks kv list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_kv_clean_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks kv clean - Delete all key=value pairs in the store\n"
    echo

  else
    printf "risks kv clean - Delete all key=value pairs in the store\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks kv clean\n"
  printf "  risks kv clean --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
risks_help_usage() {
  if [[ -n $long_usage ]]; then
    printf "risks help - Show help about a command\n"
    echo

  else
    printf "risks help - Show help about a command\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  risks help [COMMAND]\n"
  printf "  risks help --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(blue "COMMAND")"
    printf "    Help subject\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if ((${#args[@]})); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/backup.sh

# backup.setup_identity creates a graveyard backup directory

# for the identity, and sets up fscrypt encryption for it.
function backup.setup_identity ()

{
    local backup_graveyard          # Where the graveyard root directory is in the backup drive
    local identity_dir              # The encrypted graveyard directory for the identity
    local identity_graveyard_backup # Full path to identity graveyard backup

    backup_graveyard="${BACKUP_MOUNT_DIR}/graveyard"

    _verbose "Creating identity graveyard directory on backup"

    # The directory name in cleartext is simply the identity name
    identity_dir=$(crypt.filename "$IDENTITY")
    identity_graveyard_backup="${backup_graveyard}/${identity_dir}"

    _verbose "Creating directory $identity_graveyard_backup"
    mkdir -p "$identity_graveyard_backup"

    # And setup fscrypt protectors on it.
    _verbose "Setting up fscrypt protectors on directory"

    echo "$FILE_ENCRYPTION_KEY" | sudo fscrypt encrypt "$identity_graveyard_backup" \
        --quiet --source=custom_passphrase --name="$identity_dir"

    _catch "Failed to encrypt identity graveyard in backup"
}

# backup.write_gpg copies the raw coffin file in the graveyard backup directory root,
# since like on the system graveyard (parent directory of the identity graveyard backup),

# since one must access it without having access to the graveyard in the first place.
function backup.write_gpg ()

{
    local backup_graveyard          # Where the graveyard root directory is in the backup drive
    local identity_dir              # The encrypted graveyard directory for the identity
    local coffin_file               # Encrypted name of the coffin file
    local coffin_path               # Full path to the identity coffin in the system graveyard
    local coffin_backup_path        # Full path to the same coffin, in the backup graveyard

    backup_graveyard="${BACKUP_MOUNT_DIR}/graveyard"

    # The directory name in cleartext is simply the identity name
    coffin_file=$(crypt.filename "${IDENTITY}-gpg.coffin")
    coffin_path="${GRAVEYARD}/${coffin_file}"

    identity_dir=$(crypt.filename "$IDENTITY")
    coffin_backup_path="${backup_graveyard}/${identity_dir}/${coffin_file}"

    if [[ -e ${coffin_backup_path} ]]; then
        sudo chattr -i "${coffin_backup_path}"

    fi

    cp -r "$coffin_path" "$coffin_backup_path"
    sudo chattr +i "${coffin_backup_path}"

}

# backup.delete_identity wipes all the data stored in a backup medium
# for a given identity. This does not include the associated identity's
# secrets in the raw hush image, if any exists.
function backup.delete_identity ()
{
    # Prepare filenames
    local backup_graveyard          # Where the graveyard root directory is in the backup drive
    local identity_graveyard_backup # Full path to identity graveyard backup
    local identity_dir              # The encrypted graveyard directory for the identity

    backup_graveyard="${BACKUP_MOUNT_DIR}/graveyard"
    identity_dir=$(crypt.filename "$IDENTITY")
    identity_graveyard_backup="${backup_graveyard}/${identity_dir}"

    echo "$FILE_ENCRYPTION_KEY" | _run sudo fscrypt unlock "$identity_graveyard_backup" --quiet

    # Delete the identity graveyard in it, and associated fscrypt policy
    if [[ -e "$identity_graveyard_backup" ]]; then
        _info "Wiping graveyard backup"
        sudo chattr -i "${identity_graveyard_backup}"/*
        _run wipe -f -r "$identity_graveyard_backup"
    else
        _warning "Identity graveyard backup does not exists, skipping."
    fi
}

# backup.tomb_delete wipes a single tomb from the graveyard backup of an identity.
# $1 - Cleartext label/name of the tomb to delete.
function backup.tomb_delete ()
{
    # Graveyard paths

    local backup_graveyard          # Where the graveyard root directory is in the backup drive
    local identity_graveyard_backup # Full path to identity graveyard backup
    local identity_dir              # The encrypted graveyard directory for the identity

    backup_graveyard="${BACKUP_MOUNT_DIR}/graveyard"
    identity_dir=$(crypt.filename "$IDENTITY")
    identity_graveyard_backup="${backup_graveyard}/${identity_dir}"

    # Tomb file
    local name="$1"

    local tomb_label        # Cleartext identifier name of the tomb
    local tomb_file         # Encrypted name of the tomb, for the tomb file itself
    local tomb_file_path    # Absolute path to the tomb file

    tomb_label="${IDENTITY}-${name}"
    tomb_file=$(crypt.filename "$tomb_label")
    tomb_file_path="${identity_graveyard_backup}/${tomb_file}.tomb"

    echo "$FILE_ENCRYPTION_KEY" | _run sudo fscrypt unlock "$identity_graveyard_backup" --quiet

    if [[ -e "$tomb_file_path" ]]; then
        _run wipe -f -r "$tomb_file_path"
    else

        _warning "Tomb file backup does not exists, skipping."
    fi

    # And lock the graveyard
    _run sudo fscrypt lock "${identity_graveyard_backup}"
}

# backup.move_gpg_master_key checks that the GPG tomb file is present in the identity

# backup, and if yes, deletes the GPG tomb from the identity system graveyard.
# This function requires the identity backup to be mounted and unlocked.
function backup.move_gpg_master_key ()
{
    local tomb_label                # Cleartext identifier name of the tomb
    local tomb_file                 # Encrypted name of the tomb, for the tomb file itself
    local backup_graveyard          # Where the graveyard root directory is in the backup drive
    local identity_graveyard        # The full path to the identity system graveyard.
    local identity_graveyard_backup # Full path to identity graveyard backup

    identity_dir=$(crypt.filename "$IDENTITY")
    identity_graveyard=$(graveyard.identity_directory "$IDENTITY")

    backup_graveyard="${BACKUP_MOUNT_DIR}/graveyard"
    identity_graveyard_backup="${backup_graveyard}/${identity_dir}"

    tomb_label="${IDENTITY}-${GPG_TOMB_LABEL}"
    tomb_file=$(crypt.filename "$tomb_label")
    tomb_file_path="${identity_graveyard}/${tomb_file}.tomb"

    # Nothing to do if the tomb is not here.

    [[ ! -e "${tomb_file_path}" ]] && return

    # Otherwise move the file to the backup
    _run sudo chattr -i "${identity_graveyard_backup}"/*
    _run sudo mv "${tomb_file_path}" "${identity_graveyard_backup}"

    _run sudo chattr +i "${identity_graveyard_backup}"/*
}

# backup.fail_device_unmounted exits the program if no backup device is mounted.
function backup.fail_device_unmounted ()

{
    if ! device.luks_mapper_found "$BACKUP_MAPPER" ; then
        _failure "No mounted backup medium found. Mount one with 'risks backup mount </dev/device>'"
    fi
}

# backup.device_unlocked returns 0 if the identity backup is currently unlocked, or 1 if closed.
function backup.device_unlocked ()
{
    [[ -z "$IDENTITY" ]] && return 1
    [[ ! $(device.luks_is_mounted "${BACKUP_MAPPER}") ]] && return 1

    identity_dir=$(crypt.filename "$IDENTITY")
    identity_graveyard=$(graveyard.identity_directory "$IDENTITY")

    backup_graveyard="${BACKUP_MOUNT_DIR}/graveyard"
    identity_graveyard_backup="${backup_graveyard}/${identity_dir}"

    unlocked=$(sudo fscrypt status "${identity_graveyard_backup}" | head -n 5 | tail -n 1 | awk '{print $2}')

    [[ $unlocked == "yes" ]] && return 0
    [[ $unlocked == "no" ]] && return 1

}

# src/lib/cleanup.sh

# Cleanup anything sensitive before exiting.
# Originally copied from tomb code.
_endgame() {

    # Prepare some random material to overwrite vars
    local rr="$RANDOM"
    while [[ ${#rr} -lt 500 ]]; do
        rr+="$RANDOM"
    done

    # Ensure no information is left in unallocated memory
    IDENTITY="$rr";		        unset IDENTITY

    FILE_ENCRYPTION_KEY="$rr";  unset FILE_ENCRYPTION_KEY

    GPG_PASS="$rr";		        unset GPG_PASS

}

# Trap functions for the _endgame event
TRAPINT()  { _endgame INT;	}
TRAPEXIT() { _endgame EXIT;	}
TRAPHUP()  { _endgame HUP;	}
TRAPQUIT() { _endgame QUIT;	}
TRAPABRT() { _endgame ABORT; }
TRAPKILL() { _endgame KILL;	}
TRAPPIPE() { _endgame PIPE;	}
TRAPTERM() { _endgame TERM;	}
TRAPSTOP() { _endgame STOP;	}

# src/lib/coffin.sh

# gpg.generate_coffin sets up, generates and formats a LUKS partition

# to be used as a container of the identity GPG keyring.
function gpg.generate_coffin ()
{
    local key_filename key_file coffin_filename coffin_file coffin_name identity_fs

    # Filenames
    key_filename=$(crypt.filename "${IDENTITY}-gpg.key")
    key_file="${HUSH_DIR}/${key_filename}"
    coffin_filename=$(crypt.filename "${IDENTITY}-gpg.coffin")
    coffin_file="${GRAVEYARD}/${coffin_filename}"
    coffin_name=$(crypt.filename "coffin-${IDENTITY}-gpg")
    identity_fs=$(crypt.filename "${IDENTITY}-gpg")

    _verbose "Generating coffin key (compatible with QRCode printing)"
    head --bytes=64 /dev/urandom > "$key_file"
    _verbose "Protecting against deletions"
    sudo chattr +i "$key_file"
    _verbose "Testing immutability of key file"
    _verbose "Output of lsattr:"
    _run lsattr "${HUSH_DIR}"
    _verbose "Output should look like (filename is encrypted):"
    _verbose "-ie- /home/user/.hush/JRklfdjklb334blkfd"

    _verbose "Creating the coffin container (50MB)"
    _run dd if=/dev/urandom of="$coffin_file" bs=1M count=50

    # Encryption
    _verbose "Laying the coffin LUKS inside the container"
    _run sudo cryptsetup -v -q --cipher aes-xts-plain64 --master-key-file "$key_file" \
        --key-size 512 --hash sha512 --iter-time 5000 --use-random \
        luksFormat "${coffin_file}" "$key_file"

    _catch "Failed to lay setup and format the coffin LUKS filesystem"
    _verbose "Testing coffin detailed output (luksDump)"
    _run sudo cryptsetup luksDump "$coffin_file"

    _catch "Failed to dump coffin LUKS filesystem"
    _verbose "Normally, we should see the UUID of the coffin, and only one key configured for it"


    _verbose "Opening the coffin for setup"
    _run sudo cryptsetup open --type luks "$coffin_file" "$coffin_name" --key-file "$key_file"
    _catch "Failed to open the coffin LUKS filesystem"

    _verbose "Testing coffin status"
    _run sudo cryptsetup status "$coffin_name"

    _catch "Failed to get status of coffin LUKS filesystem"

    _verbose "Formatting the coffin filesystem (ext4)"
    _run sudo mkfs.ext4 -m 0 -L "$identity_fs" "/dev/mapper/${coffin_name}"
    _catch "Failed to make ext4 filesystem on coffin partition"
}

# gpg.delete_coffin deletes a coffin file in the system graveyard,
# and its corresponding decryption key in the hush device.
function gpg.delete_coffin ()
{
    local key_filename key_file coffin_filename coffin_file

    # Coffin
    coffin_filename=$(crypt.filename "${IDENTITY}-gpg.coffin")
    coffin_file="${GRAVEYARD}/${coffin_filename}"

    if [[ -e "$coffin_file" ]]; then
        _run wipe -f -r "$coffin_file"
    else

        _warning "Coffin file does not exists, skipping."
    fi

    # Key
    key_filename=$(crypt.filename "${IDENTITY}-gpg.key")
    key_file="${HUSH_DIR}/${key_filename}"

    if [[ -e "$key_file" ]]; then

        sudo chattr -i "${key_file}"

        _run wipe -f -r -P 10 "$key_file"
    else
        _warning "Coffin key does not exists, skipping."
    fi
}

# gpg.open_coffin opens/mounts the identity GPG keyring coffin file.
# It requires an identity to be set, and its corresponding passphrase
function gpg.open_coffin ()
{
    local key_filename          # Encrypted name for the key file
    local key_file              # Absolute path to this key
    local coffin_filename       # Encrypted name of the coffin
    local coffin_file           # Absolute path to the coffin
    local mapper                # LUKS Mapper name
    local mount_dir             # Mount point to use for the coffin mapper

    key_filename=$(crypt.filename "${IDENTITY}-gpg.key")
    key_file="${HUSH_DIR}/${key_filename}"
    coffin_filename=$(crypt.filename "${IDENTITY}-gpg.coffin")
    coffin_file="${GRAVEYARD}/${coffin_filename}"
    mapper=$(crypt.filename "coffin-${IDENTITY}-gpg")

    mount_dir="${HOME}/.gnupg"

    if [[ ! -f "${coffin_file}" ]]; then
        _failure "I'm looking for $coffin_file but no coffin file found in $GRAVEYARD"
    fi

    if device.luks_is_mounted "/dev/mapper/${mapper}" ; then
        _verbose "Coffin file $coffin_file is already open and mounted"
        return 0
    fi

    if ! device.luks_is_opened "${mapper}"; then
        if ! _run sudo cryptsetup open --type luks "$coffin_file" "$mapper" --key-file "$key_file" ; then
            _failure "I can not open the coffin file $coffin_file"
        fi
    fi

    mkdir -p "${mount_dir}" &> /dev/null

    if ! _run sudo mount -o rw,user /dev/mapper/"${mapper}" "$mount_dir" ; then
        _failure "Coffin file $coffin_file can not be mounted on $mount_dir"
    fi

    _verbose "Coffin $coffin_file has been opened in $mount_dir"

    sudo chown "${USER}" "$mount_dir"
    sudo chmod 0700 "$mount_dir"

    # Set the identity as active, and unlock access to its GRAVEYARD directory
    identity.set_active "$IDENTITY"

    local identity_dir identity_graveyard

    identity_dir=$(crypt.filename "$IDENTITY")
    identity_graveyard="${GRAVEYARD}/$identity_dir"

    # Ask fscrypt to let us access it. While this will actually decrypt the files'
    # names and content, this does not prevent our own obfuscated names; the end
    # result is that all NAMES are obfuscated twice (once us, once fscrypt) and
    # the contents are encrypted once (fscrypt).
    echo "$FILE_ENCRYPTION_KEY" | _run sudo fscrypt unlock "$identity_graveyard" --quiet

    _verbose "Identity directory ($identity_graveyard) is unlocked"
}

# gpg.close umounts/closes the identity GPG keyring coffin file.
function gpg.close_coffin ()
{
    local coffin_filename coffin_file mapper mount_dir

    coffin_filename=$(crypt.filename "${IDENTITY}-gpg.coffin")
    coffin_file="${GRAVEYARD}/${coffin_filename}"
    mapper=$(crypt.filename "coffin-${IDENTITY}-gpg")

    mount_dir="${HOME}/.gnupg"

    # Gpg-agent is an asshole spawning thousands of processes
    # without anyone to ask for them.... security they said
    gpgconf --kill gpg-agent

    if device.luks_is_mounted "/dev/mapper/${mapper}" ; then
        if ! _run sudo umount "${mount_dir}" ; then
            _failure "Coffin file ${coffin_file} can not be umounted from ${mount_dir}"
        fi
    fi

    if device.luks_is_opened "$mapper"; then
        if ! _run sudo cryptsetup close /dev/mapper/"${mapper}" ; then
            _failure "Coffin file $coffin_file can not be closed"
        fi
    else
        _verbose "Coffin file $coffin_file is already closed"
        return 0
    fi

    local identity_dir identity_graveyard

    # Lock the identity's graveyard directory
    identity_dir=$(crypt.filename "$IDENTITY")
    identity_graveyard="${GRAVEYARD}/${identity_dir}"
    _run sudo fscrypt lock "${identity_graveyard}"

    identity.set_active # An empty  identity will trigger a wiping of the file

    _verbose "Coffin file $coffin_file has been closed"
}

# gpg.list_coffins prints a list of all currently mounted GPG coffin files.
function gpg.list_coffins ()
{
    local coffins_num=0
    local coffins

    ls_filtered=(ls -1 --ignore={dmroot,control,hush,pendev} --ignore='tomb*')

    if "${ls_filtered[@]}" &> /dev/null; then
        coffins=$("${ls_filtered[@]}" /dev/mapper)
        coffins_num=$(echo "$coffins" | wc -l)
    fi

    if [[ $coffins_num -gt 0 ]]; then
        _info "Coffins currently opened:"
        echo "$coffins" | xargs
    else
        _info "No opened coffins"
    fi
}

# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/config.sh
config_init() {
    RISKS_CONFIG_FILE=${RISKS_CONFIG_FILE-${RISKS_DIR}/config.ini}
    [[ -f "$RISKS_CONFIG_FILE" ]] || {

        _info "Writing default configuration file to ${RISKS_CONFIG_FILE}"

    cat << EOF > "$RISKS_CONFIG_FILE"

; RISKS Vault (domU) Configuration file

; You can either edit this file in place, set values
; through the 'risks config' commands.

; Device file path to the hush partition
SDCARD_ENC_PART=/dev/hush

; Name of LUKS mapper to hush partition
SDCARD_ENC_PART_MAPPER=hush

; Enable sound when hush device is mounted (0: enabled, 1: disabled)
SDCARD_QUIET=0

; Directory mount point for the hush device
HUSH_DIR=/home/user/.hush

; Directory where to store tomb files
GRAVEYARD=/home/user/.graveyard

; Name of LUKS mapper to backup partition
BACKUP_MAPPER=pendev

; Default timeout after which the clipboard is wiped after being filled with GPG passphrase.
GPGPASS_TIMEOUT=45

EOF
    }
}

config_get() {

    local key=$1
    local regex="^$key *= *(.+)$"
    local value=""

    config_init

    while IFS= read -r line || [ -n "$line" ]; do
        if [[ $line =~ $regex ]]; then
            value="${BASH_REMATCH[2]}" # Changed to 2 because ZSH indexes start at 1
            break
        fi
    done < "$RISKS_CONFIG_FILE"

    echo "$value"
}

config_set() {

    local key=$1
    shift
    local value="$*"

    config_init

    local regex="^($key) *= *.+$"
    local output=""
    local found_key=""
    local newline

    while IFS= read -r line || [ -n "$line" ]; do
        newline=$line
        if [[ $line =~ $regex ]]; then
            found_key="${BASH_REMATCH[2]}"
            newline="$key = $value"
            output="$output$newline\n"
        elif [[ $line ]]; then
            output="$output$line\n"
        fi
    done < "$RISKS_CONFIG_FILE"

    if [[ -z $found_key ]]; then
        output="$output$key = $value\n"
    fi

    printf "%b\n" "$output" > "$RISKS_CONFIG_FILE"
}

config_del() {
    local key=$1

    local regex="^($key) *="
    local output=""

    config_init

    while IFS= read -r line || [ -n "$line" ]; do
        if [[ $line ]] && [[ ! $line =~ $regex ]]; then
            output="$output$line\n"
        fi
    done < "$RISKS_CONFIG_FILE"

    printf "%b\n" "$output" > "$RISKS_CONFIG_FILE"
}

config_show() {
    config_init
    cat "$RISKS_CONFIG_FILE"
}

config_keys() {
    # zsh compat
    setopt local_options BASH_REMATCH

    local regex="^([a-zA-Z0-9_\-\/\.]+) *="

    config_init

    local keys=()
    local key

    while IFS= read -r line || [ -n "$line" ]; do
        if [[ $line =~ $regex ]]; then
            key="${BASH_REMATCH[1]}"
            key="${key//\=/}"
            [[ -n "$key" ]] && keys+=("$key")
        fi
    done < "$RISKS_CONFIG_FILE"
    echo "${keys[@]}"
}

config_has_key() {
    [[ $(config_get "$1") ]]
}

# src/lib/crypt.sh

# crypt.set_file_obfs_key is only called once per risks run,
# and does not need any password prompt to be used: it just

# generates a deterministic key based on known inputs.
function crypt.set_file_obfs_key ()
{
    local identity="$1"
    local key
    key=$(print "$identity" | spectre -q -n -s 0 -F n -t n -u "$identity" "$FILE_ENCRYPTION")
    print "$key"
}

# crypt.filename takes a filename as input, and uses the currently

# set identity to produce an random name to use as a file/directory name.
# $1 - Name/string to obfuscate.
function crypt.filename ()
{
    local filename="$1"
    local encrypted

    # -q            Quiet: just output the password/filename
    # -n            Don't append a newline to the password output
    # -s 0          Read passphrase from stdinput (fd 0)
    # -F n          No config file output
    # -t n          Output a nine characters name, without symbols
    # -u ${user}    User for which to produce the password/name
    encrypted=$(print "$FILE_ENCRYPTION_KEY" | spectre -q -n -s 0 -F n -t n -u "$IDENTITY" "$filename")
    print "${encrypted}"
}

# crypt.passphrase returns a spectre-generated secret key.
# Uses the current IDENTITY as set by identity.set <identity_name>
# $1 - spectre password value / seed input
function crypt.passphrase ()
{
    local passname="${1}"

    local passphrase

    # Forge command
    local cmd=(spectre -q -n -F n)
    local spectre_params=(-t K -P 512 -u "$IDENTITY" "$passname")

    passphrase=$("${cmd[@]}" "${spectre_params[@]}")

    print "$passphrase"
}

# crypt.unlock_directory uses the current identity

# to unlock an fscrypt-encrypted directory.
function crypt.unlock_directory ()
{
    [[ ! -e "$1" ]] && return
    echo "$FILE_ENCRYPTION_KEY" | _run sudo fscrypt unlock "$1" --quiet
}

# crypt.lock_directory locks an fscrypt-encrypted directory.
function crypt.lock_directory ()
{
    [[ ! -e "$1" ]] && return
    _run sudo fscrypt lock "${1}"
}


# _is_found() {
# 	# returns 0 if binary is found in path
# 	[[ -z $1 ]] && return 1
# 	command -v "$1" 1>/dev/null 2>/dev/null
# 	return $?
# }

# pinentry_assuan_getpass() {
# 	# simply prints out commands for pinentry's stdin to activate the
# 	# password dialog
# 	cat <<EOF
# OPTION ttyname=$TTY
# OPTION lc-ctype=$LANG
# SETTITLE $title
# SETDESC $description
# SETPROMPT Password:
# GETPIN
# EOF
# }
#
# # Ask user for a password
# # Wraps around the pinentry command, from the GnuPG project, as it
# # provides better security and conveniently use the right toolkit.
# ask_password() {
#
# 	local description="$1"
# 	local title="${2:-Enter tomb password.}"
# 	local output
# 	local password
# 	local gtkrc
# 	local theme
# 	local pass_asked
#
# 	# Distributions have broken wrappers for pinentry: they do
# 	# implement fallback, but they disrupt the output somehow.	We are
# 	# better off relying on less intermediaries, so we implement our
# 	# own fallback mechanisms. Pinentry supported: curses, gtk-2, qt4, qt5
# 	# and x11.
#
# 	# make sure LANG is set, default to C
# 	LANG=${LANG:-C}
#
# 	_verbose "asking password with tty=$TTY lc-ctype=$LANG"
#
# 	pass_asked=0
#
# 	if [[ -n $WAYLAND_DISPLAY ]]; then
# 		_verbose "wayland display detected"
# 		_is_found "pinentry-gnome3" && {
# 			_verbose "using pinentry-gnome3 on wayland"
# 			output=$(pinentry_assuan_getpass | pinentry-gnome3)
# 			pass_asked=1
# 		}
# 	fi
# 	if [[ -n $DISPLAY ]] && [[ $pass_asked == 0 ]]; then
# 		_verbose "X11 display detected"
# 		if _is_found "pinentry-gtk-2"; then
# 			_verbose "using pinentry-gtk2"
# 			output=$(pinentry_assuan_getpass | pinentry-gtk-2)
# 			pass_asked=1
# 		elif _is_found "pinentry-x11"; then
# 			_verbose "using pinentry-x11"
# 			output=$(pinentry_assuan_getpass | pinentry-x11)
# 			pass_asked=1
# 		elif _is_found "pinentry-gnome3"; then
# 			_verbose "using pinentry-gnome3 on X11"
# 			output=$(pinentry_assuan_getpass | pinentry-gnome3)
# 			pass_asked=1
# 		elif _is_found "pinentry-qt5"; then
# 			_verbose "using pinentry-qt5"
# 			output=$(pinentry_assuan_getpass | pinentry-qt5)
# 			pass_asked=1
# 		elif _is_found "pinentry-qt4"; then
# 			_verbose "using pinentry-qt4"
# 			output=$(pinentry_assuan_getpass | pinentry-qt4)
# 			pass_asked=1
# 		fi
# 	fi
# 	if [[ $pass_asked == 0 ]]; then
# 		_verbose "no display detected"
# 		_is_found "pinentry-curses" && {
# 			_verbose "using pinentry-curses with no display"
# 			output=$(pinentry_assuan_getpass | pinentry-curses)
# 			pass_asked=1
# 		}
# 	fi
#
# 	[[ $pass_asked == 0 ]] &&
# 		_failure "Cannot find any pinentry-curses and no DISPLAY detected."
#
# 	# parse the pinentry output
# 	local pinentry_error
# 	for i in ${(f)output}; do
# 		[[ "$i" =~ "^ERR.*" ]] && {
# 			pinentry_error="${i[(w)3]}"
# 		}
#
# 		# here the password is found
# 		[[ "$i" =~ "^D .*" ]] && password="${i##D }";
# 	done
#
# 	[[ ! -z $pinentry_error ]] && [[ -z $password ]] && {
#         _warning "Pinentry error: ::1 error::" "${pinentry_error}"
# 		print "canceled"
# 		return 1
# 	}
#
# 	[[ -z $password ]] && {
# 		_warning "Empty password"
# 		print "empty"
# 		return 1
# 	}
#
# 	print "$password"
# 	return 0
# }

# src/lib/gpg.sh

# gpg.setup_keyring creates a RAMDisk and sets up the GPG directory/keyring

# in it, with configuration files related to usage/display/generation stuff.
function gpg.setup_keyring ()
{
    _verbose 'Creating directory & setting permissions'
    rm -fR "${RAMDISK}"
    mkdir "${RAMDISK}"
    _run sudo mount -t tmpfs -o size=10m ramdisk "${RAMDISK}"
    _catch "Failed to mount tmp fs on ramdisk"
    sudo chown "${USER}" "${RAMDISK}"

    _catch "Failed to set ownership to ${RAMDISK}"
    sudo chmod 0700 "${RAMDISK}"

    _catch "Failed to change mod 0700 to ${RAMDISK}"

    _verbose "Testing ramdisk read/write"
    _verbose "$(mount | grep ramdisk)"
    _verbose "Previous command should look like this: \n\n\
        ramdisk on /home/user/ramdisk type tmpfs (rw,relatime,size=10240k) \n\
        ramdisk on /rw/home/user/ramdisk type tmpfs (rw,relatime,size=10240k) \n"

    touch "${RAMDISK}/delme" && rm "${RAMDISK}/delme"

    _catch "Failed to test write file ${1}"

    # Configuration files
    _verbose "Writing default GPG configuration file"
    cat >"${RAMDISK}/gpg.conf" <<EOF
# Avoid information leaked
no-emit-version
no-comments
export-options export-minimal

# Options for keys listing
keyid-format 0xlong
with-fingerprint
with-keygrip
with-subkey-fingerprint

# Displays the validity of the keys
list-options show-uid-validity
verify-options show-uid-validity

# Limits preferred algorithms
personal-cipher-preferences AES256
personal-digest-preferences SHA512
default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed

# Options for asymmetric encryption
cipher-algo AES256
digest-algo SHA512
cert-digest-algo SHA512
compress-algo ZLIB
disable-cipher-algo 3DES
weak-digest SHA1

# Options for symmetric encryption
s2k-cipher-algo AES256
s2k-digest-algo SHA512
s2k-mode 3
s2k-count 65011712
EOF
}

# gpg.generate_keys creates master/subkey pairs for a new identity.
# $1 - Name of the GPG owner
# $2 - Email recipient
# $3 - Subkeys expiry date

function gpg.generate_keys ()
{
    local name="$1"
    local email="$2"
    local expiry="$3"

    local expiry_date fingerprint

    # Output the identity batch file with values
    _verbose "Writing GPG batch file to ramdisk"
    cat >"${RAMDISK}/primary_key_unattended" <<EOF
%echo Generating EDDSA key (Ed25519 curve)
Key-Type: eddsa

Key-Curve: Ed25519

Key-Usage: sign
Key-Length: 4096
Name-Real: $name

Name-Email: $email

Expire-Date: 0
Passphrase: $GPG_PASS

%commit
%echo done
EOF

    # Generate key and get rid of batch file
    _verbose "Generating primary key from batch file"
    _run gpg --batch --gen-key "${RAMDISK}/primary_key_unattended"

    _catch "Failed to generate keys from batch file"
    _verbose "Deleting batch file"
    _run wipe -f -P 10 "${RAMDISK}/primary_key_unattended"

    _catch "Failed to wipe batch file: contains the identity passphrase"


    expiry_date="$(date +"%Y-%m-%d" --date="${expiry}")"

    fingerprint=$(gpg -K "${email}" | grep fingerprint | head -n 1 | cut -d= -f2 | sed 's/ //g')
    _info "Fingerprint: ${fingerprint}"

    local gpg_base_cmd=(gpg --pinentry-mode loopback --batch --no-tty --yes --passphrase-fd 0 --quick-add-key "${fingerprint}")

    _verbose "Generating encryption subkey-pair"
    echo "$GPG_PASS" | _run "${gpg_base_cmd[@]}" cv25519 encr "${expiry_date}" &> /dev/null
    _catch "Failed to generate encryption subkey-pair"

    _verbose "Generating signature subkey-pair"
    echo "$GPG_PASS" | _run "${gpg_base_cmd[@]}" ed25519 sign "${expiry_date}" &> /dev/null
    _catch "Failed to generate signature subkey-pair"

    _verbose "Generating authentication subkey-pair"
    echo "$GPG_PASS" | _run "${gpg_base_cmd[@]}" ed25519 auth "${expiry_date}" &> /dev/null
    _catch "subkeys" "Failed to generate authentication subkey-pair. Continuing still"

    _verbose "Directory structure:"
    _verbose "$(tree "${RAMDISK}")"
}

# gpg.cleanup_keyring performs several important, but quite unrelated, tasks:
# - Moves the GPG keyring of an identity into its coffin
# - Checks visually that files are where expected (if verbose flag set)
# - Removes the private keys from the keyring that is to be used daily
function gpg.cleanup_keyring ()
{
    local email="$1"

    local tmp_filename tmp_dir coffin_name

    # Filenames
    tmp_filename=$(crypt.filename "${IDENTITY}-gpg")
    tmp_dir="/tmp/${tmp_filename}"
    coffin_name=$(crypt.filename "coffin-${IDENTITY}-gpg")

    # Making tmp directory
    _verbose "Creating temp directory and mounting coffin"
    mkdir "$tmp_dir"
    sudo mount /dev/mapper/"${coffin_name}" "$tmp_dir"

    _catch "Failed to mount coffin partition on $tmp_dir"

    sudo chown "$USER" "$tmp_dir"
    _verbose "Testing coffin filesystem"
    _verbose "$(mount | grep "$tmp_filename")"

    _verbose "Copying GPG files in coffin"
    cp -fR "$RAMDISK"/* "$tmp_dir" || _warning "Failed to copy one or more files into coffin"
    _verbose "Setting GPG files immutable"
    sudo chattr +i "$tmp_dir"/private-keys-v1.d/*
    _verbose "Closing coffin"
    sudo chattr +i "$tmp_dir"/openpgp-revocs.d/*
    sudo umount "$tmp_dir" || _warning "Failed to unmount tmp directory $TMP"
    sudo cryptsetup close /dev/mapper/"$coffin_name"

    _catch "Failed to close LUKS filesystem for identity"

    # Clearing RAMDisk
    _verbose "Wiping and unmounting ramdisk"
    _run sudo wipe -rf "$RAMDISK"/*
    _catch "Failed to wipe $RAMDISK directory"
    sudo umount -l "$RAMDISK" || _warning "Failed to unmount ramdisk $RAMDISK"


    _verbose "Checking directory contents"
    _verbose "$(tree "$HUSH_DIR" "$GRAVEYARD")"
    _verbose "Should look like this:           \n\n \
        /home/user/.hush                           \n    \
         fjdri3kff2i4rjkFA (joe-gpg.key)        \n    \
        /home/user/.graveyard                      \n    \
         fejk38RjhfEf13 (joe-gpg.coffin)        \n"

    _verbose "Test opening and closing coffin for $IDENTITY"
    gpg.close_coffin
    gpg.open_coffin


    _verbose "Removing GPG private keys"

    local tomb_size keygrip fingerprint

    tomb_size=15
    fingerprint=$(gpg -K "${email}" | grep fingerprint | head -n 1 | cut -d= -f2 | sed 's/ //g')

    # Creating tomb file for private keys and moving them
    _verbose "Creating tomb file for for storing GPG privates"
    _run tomb.create "$GPG_TOMB_LABEL" $tomb_size
    _verbose "Opening tomb file"
    _run tomb.open "$GPG_TOMB_LABEL"

    keygrip="$(gpg -K | grep Keygrip | head -n 1 | cut -d= -f 2 | sed 's/ //g').key"
    _verbose "Keygrip: $keygrip"

    _verbose "Copying private data to tomb"
    _verbose "Private keys"
    cp "${RAMDISK}"/private-keys-v1.d/"${keygrip}" "${HOME}"/.tomb/"${GPG_TOMB_LABEL}"/
    _verbose "Revocation certificates"
    cp "${RAMDISK}"/openpgp-revocs.d/"${fingerprint}".rev "${HOME}"/.tomb/"${GPG_TOMB_LABEL}"/

    # Deleting keys from keyring
    _verbose "Wiping corresponding files in GPG keyring"
    sudo chattr -i "${RAMDISK}"/private-keys-v1.d/"${keygrip}"

    _run wipe -rf "${RAMDISK}"/private-keys-v1.d/"${keygrip}" \
        || _warning "Failed to delete master private key from keyring !"

    sudo chattr -i "${RAMDISK}"/openpgp-revocs.d/"${fingerprint}".rev
    _run wipe -rf "${RAMDISK}"/openpgp-revocs.d/"${fingerprint}".rev \
        || _warning "Failed to delete master key revocation from keyring !"

    # Verbose checks
    _verbose "Printing GPG keyring. Should have 'sec#' instead of 'pub'"
    _verbose "$(gpg -K)"
    _verbose "Closing GPG tomb file"
    _run tomb.close "$GPG_TOMB_LABEL" "$IDENTITY"

    # Cleanup files
    rm -rf "$tmp_dir"
}

# gpg.generate_subkeys generates some subkeys depending on which parameters are passed.
# $1 - Key algorithm to use
# $2 - Fingerprint of the master key
# $3 - Expiry date of the subkeys to generate.
function gpg.generate_subkeys ()
{
    local algo="${1}"
    local fingerprint="${2}"
    local expiry_date="${3}"

    local gpg_base_cmd=(gpg --pinentry-mode loopback --batch --no-tty --yes --passphrase-fd 0 --quick-add-key "${fingerprint}")

    # Signing subkey
    if [[ "${args['--sign']}" -eq 1 ]]; then
        _info "Generating signature subkey-pair"
        echo "$GPG_PASS" | _run "${gpg_base_cmd[@]}" "${algo}" sign "${expiry_date}" &> /dev/null
        _catch "Failed to generate subkey-pair"
    fi

    # Encryption subkey

    if [[ "${args['--encrypt']}" -eq 1 ]]; then
        if [[ "${algo}" == "ed25519" ]]; then
            algo="cv25519"
        fi
        _info "Generating encryption subkey-pair"
        echo "$GPG_PASS" | _run "${gpg_base_cmd[@]}" "${algo}" encr "${expiry_date}" &> /dev/null
        _catch "Failed to generate subkey-pair"
    fi
}

# gpg.passphrase_is_cached returns 0 if the gpg-agent has the private cached, or 1 if not.
function gpg.passphrase_is_cached ()
{
    local key
    key=$(gpg-connect-agent 'keyinfo --list' /bye 2>/dev/null | awk 'BEGIN{CACHED=0} /^S/ {if($7==1){CACHED=1}} END{if($0!=""){print CACHED} else {print "none"}}')

    if [[ "$key" == "CACHED" ]]; then
        return 0
    else
        return 1
    fi

    # Just in case
    return 1
}

# gpg.master_key_status returns true if the master private

# GPG key is present in the keyring, or false if it's absent.
function gpg.master_key_status ()

{
    local key_status masterkey_available

    key_status="$(gpg --list-secret-keys | head -n 3 | tail -n 1 | awk '{print $1;}')"

    if [[ "${key_status}" == "sec" ]]; then
        masterkey_available=true
    elif [[ "${key_status}" == "sec#" ]]; then
        masterkey_available=false
    fi

    print "${masterkey_available}"
}

# src/lib/graveyard.sh

# graveyard.create generates a private directory in the
# graveyard for a given identity, with fscrypt support.
function graveyard.create ()
{
    local identity_dir identity_graveyard

    # Always make sure the root graveyard directory exists
    if [[ ! -d ${GRAVEYARD} ]]; then
        _verbose "Creating directory $GRAVEYARD"
        mkdir -p "$GRAVEYARD"
    fi

    # The directory name in cleartext is simply the identity name
    identity_dir=$(crypt.filename "$IDENTITY")
    identity_graveyard="${GRAVEYARD}/${identity_dir}"

    # Make the directory
    _verbose "Creating identity graveyard directory"
    mkdir -p "$identity_graveyard"

    # And setup fscrypt protectors on it.
    _verbose "Setting up fscrypt protectors on directory"
    echo "$FILE_ENCRYPTION_KEY" | sudo fscrypt encrypt "$identity_graveyard" \
        --quiet --source=custom_passphrase --name="$identity_dir"
    }

# graveyard.delete wipes the graveyard directory of an identity.
function graveyard.delete ()
{
    local identity_graveyard

    identity_graveyard=$(graveyard.identity_directory "$IDENTITY")

    echo "$FILE_ENCRYPTION_KEY" | _run sudo fscrypt unlock "$identity_graveyard" --quiet

    sudo chattr -i "${identity_graveyard}"/*
    _run wipe -f -r "$identity_graveyard"
}

# graveyard.identity_directory returns the path to an identity's graveyard directory,
# and decrypts (gives access to) this directory, since this function was called
# because we need some resource stored within.
function graveyard.identity_directory ()
{
    local identity="$1"

    local identity_dir identity_graveyard

    # Compute the directory names and absolute paths
    identity_dir=$(crypt.filename "${identity}")
    identity_graveyard="${GRAVEYARD}/${identity_dir}"

    print "${identity_graveyard}"
}

# src/lib/hush.sh

# hush.format_partitions is a separate function because we must
# avoid bashly CLI framework to indent the Heredoc in there.
# $1 - Path to hush full sd_drive, e.g /dev/xvdi
# $2 - Start of the encrypted partition, in number of sectors.
function hush.format_partitions ()
{
    local sd_drive="$1"
    local start_enc_sectors="$2"

    nl=$'\n' # Needed because EOF does not preserve some newlines.
    _run sudo fdisk -u "${sd_drive}" <<EOF
n
p
1

+${start_enc_sectors}
n
p
2

$nl
w

EOF
}

# hush.fail_device_unmounted exits the program if the hush device is not mounted.
function hush.fail_device_unmounted ()
{
    if ! device.hush_is_mounted ; then
        _failure "The hush device is not mounted. Mount it first and rerun the command."
    fi
}

# hush.write_risks_scripts copies the various vault risks scripts in a special directory in the
# hush partition, along with a small installation scriptlet, so that upon mounting the hush
# somewhere else, the user can quickly install and use the risks on the new machine.
function hush.write_risks_scripts ()
{
    local udev_rules="$1"

    _info "Copying risks scripts onto the hush partition"

    # Scripts/program
    mkdir -p "$RISKS_SCRIPTS_INSTALL_PATH"
    sudo cp "$(which risks)" "$RISKS_SCRIPTS_INSTALL_PATH"
    sudo chmod go-rwx "$RISKS_SCRIPTS_INSTALL_PATH"
    sudo cp /usr/local/share/zsh/site-functions/_risks "$RISKS_SCRIPTS_INSTALL_PATH"

    cat >"${RISKS_SCRIPTS_INSTALL_PATH}/install" <<'EOF'
#!/usr/bin/env zsh

local INSTALL_SCRIPT_DIR="${0:a:h}"
local INSTALL_SCRIPT_PATH="$0"
local BINARY_INSTALL_DIR="${HOME}/.local/bin"
local COMPLETIONS_INSTALL_DIR="${HOME}/.local/share/zsh/site-functions"


#
echo "Installing risks script in ${BINARY_INSTALL_DIR}"
if [[ ! -d "${BINARY_INSTALL_DIR}" ]]; then
    mkdir -p "${BINARY_INSTALL_DIR}"
fi
cp "${INSTALL_SCRIPT_PATH}" "${BINARY_INSTALL_DIR}"
sudo chmod go-rwx "${INSTALL_SCRIPT_PATH}"
sudo chmod u+x "${INSTALL_SCRIPT_PATH}"


#
echo "Installing risks completions in ${COMPLETIONS_INSTALL_DIR}"
if [[ ! -d "${COMPLETIONS_INSTALL_DIR}" ]]; then
    echo "Completions directory does not exist. Creating it."
    echo "You should add it to ${FPATH} and reload your shell"
    mkdir -p "${COMPLETIONS_INSTALL_DIR}"
fi
cp "${INSTALL_SCRIPT_DIR}/_risks" "${COMPLETIONS_INSTALL_DIR}"

echo "Done installing risks scripts."
EOF

    # Hush device udev rules: UUID is evaluated at format time here,
    # then installed onto the hush, so value freezed once and for all.
    cat >"${RISKS_SCRIPTS_INSTALL_PATH}/install_udev_rules" <<EOF
#!/bin/sh

# Maps this device ID to be automatically mounted as /dev/hush mapper.
${udev_rules}
EOF

    sudo chmod go-rwx "$RISKS_SCRIPTS_INSTALL_PATH/install_udev_rules"
}

# src/lib/identity.sh

# identity.set is used to propagate our various IDENTITY related variables
# so that all functions that will be subsequently called can access them.
# This function also takes care of checking if there is already an active
# identity that should be used, in case the argument is empty or none.
#
# $1 - The identity to use.
function identity.set ()

{
    local identity="$1"

    # This will throw an error if we don't have an identity from any source.
    IDENTITY=$(identity.active_or_specified "$identity")
    _catch "Command requires either an identity to be active or given as argument"

    # Then set the file encryption key for for it.
    FILE_ENCRYPTION_KEY=$(crypt.set_file_obfs_key "$IDENTITY")
}

# identity.set_active sets the name as an ENV variable that we can use in further functions and commands.

# This function slightly differs from identity.set in that it does not set the active identity and its

# values in the script run itself: it only populates stuff that is to be used in other calls of risks.
#
# $1 - The name to use. If empty, just resets the identity.
function identity.set_active ()
{
    # If the identity is empty, wipe the identity file
    if [[ -z ${1} ]] && [[ -e ${RISKS_IDENTITY_FILE} ]]; then
        identity=$(cat "${RISKS_IDENTITY_FILE}")
        _run wipe -s -f -P 10 "${RISKS_IDENTITY_FILE}" || _warning "Failed to wipe identity file !"

        _verbose "Identity '${identity}' is now inactive, (name file deleted)"
        _info "Identity '${identity}' is now INACTIVE"
        return
    fi

    # If we don't have a file containing the

    # identity name, populate it.
    if [[ ! -e ${RISKS_IDENTITY_FILE} ]]; then
        print "$1" > "${RISKS_IDENTITY_FILE}"
    fi

    _verbose "Identity '${1}' is now active (name file written)"
    _info "Identity '${1}' is now ACTIVE"
}

# identity.active returns 0 if an identity is unlocked, 1 if not.
function identity.active ()

{
    [[ ! -e "${RISKS_IDENTITY_FILE}" ]] && return 1
    [[ -z "$(cat "${RISKS_IDENTITY_FILE}")" ]] && return 1
    return 0
}

# identity.fail_none_active exits the program if there is no identity active or specified with args.

function identity.fail_none_active ()
{
    if ! identity.active ; then
        _failure "This command requires an identity to be active"
    fi
}

# identity.active_or_specified checks that either an identity is active,

# or that the passed argument is not empty. If the identity is not empty
# it is echoed back to the caller.
#
# $1 - An identity name
#
# Returns:
# 0 - Identity is non-nil, provided either from arg or by the active
# 1 - None have been given
function identity.active_or_specified ()
{
    [[ -z "${1}" ]] && ! identity.active && return 1
    [[ -n "${1}" ]] && print "${1}" && return 0

    print "$(cat "${RISKS_IDENTITY_FILE}")"
}

# identity.get_args_name either returns the name given as parameter, or
# generates a random (burner) one and prints it to the screen.
function identity.get_args_name ()

{
    local name

    if [[ -z "${1}" ]] && [[ "${args['--burner']}" -eq 0 ]]; then
        _failure "Either an identity name is required, or the --burner flag"

    fi

    # Either use the provided one
    if [[ -n "${1}" ]]; then
        name="${1}"
    elif [[ "${args['--burner']}" -eq 1 ]]; then
        name="$(rig -m | head -n 1)"
        name="${name// /_}"
    fi

    print "${name}"
}

# identity.get_args_mail returns a correctly formatted mail given either a fully specified

# one as positional, or a generated/concatenated one from the username argument.
function identity.get_args_mail ()
{
    local name="$1"
    local email="$2"

    [[ -n "${email}" ]] && print "${email}" && return

    email="${args['--mail']}"

    # Return either the mail flag with the name

    [[ -n "${email}" ]] && print "${name}@${email}"
    # Or the lowercase name without spaces
    print "${name// /_}"
}

# identity.get_args_expiry returns a correctly formatted expiry date for a GPG key.
# If no arguments are passed to the call, the expiry date is never.
function identity.get_args_expiry ()

{
    local expiry

    if [[ -n "${1}" ]]; then
        expiry="${1}"
        expiry_date="$(date +"%Y-%m-%d" --date="${expiry}")"

    else
        expiry_date="never"
    fi

    print "${expiry_date}"
}

# src/lib/init.sh

# This file contains additional IDENTITY initialization functions.

# $1 - Email recipient to use for password-store (GPG recipient)
function tomb.create_password_store ()

{
    local email="${1}"

    _verbose "Creating tomb file for pass"
    _run tomb.create "$PASS_TOMB_LABEL" 20 "$IDENTITY"
    _verbose "Opening password store"
    _run tomb.open "$PASS_TOMB_LABEL" "$IDENTITY"
    _verbose "Initializating password store with recipient $email"
    _run pass init "$email"
    _verbose "Closing pass tomb file"
    _run tomb.close "$PASS_TOMB_LABEL" "$IDENTITY"
}

# tomb.create_management creates a default management tomb

# in which, between others, the key=value store is being kept.
function tomb.create_management ()
{
    _verbose "Creating tomb file for management (key=value store, etc)"
    _run tomb.create "$MGMT_TOMB_LABEL" 10 "$IDENTITY"
    _verbose "Opening management tomb"
    _run tomb.open "$MGMT_TOMB_LABEL" "${IDENTITY}"
    _verbose "Closing management tomb"
    _run tomb.close "$MGMT_TOMB_LABEL" "$IDENTITY"
}

# src/lib/log.sh


# Section is set either by functions or simple calls,
# so that logging can inform on the component working.
section='risks'

# When multiple sections are used within a single risks
# operation, we padd them, for clearer/better aesthetics.
section_padding=0

# Last log level used. Inline logging uses this.
last_level="message"

# maps levels to their display color
declare -A log_colors
log_colors=(
    [verbose]="blue"
    [message]="white"
    [warning]="yellow"
    [success]="green"
    [failure]="red"
)

# maps levels to notice characters.
declare -A log_chars
log_chars=(
    [inline]=" > "
    [verbose]="[D]"
    [message]=" . "
    [warning]="[W]"
    [success]="(*)"
    [failure]="[E]"
)


# Simple way of setting the section and to update the padding
_in_section ()
{
    section="$1"
    if [[ -n "${2}" ]]; then
        section_padding="$2"
    fi
}

function is_verbose_set () {
    if [[ "${args['--verbose']}" -eq 1 ]]; then
        return 0
    else
        return 1
    fi
}

# Messaging function with pretty coloring
function _msg()

{
    # Check if we have been provided a section name,

    # and if not, that the section is set to a default.
    if [[ ${#@} -lt 3 ]]; then
        local progname="$section"
        if [[ -z "$progname" ]]; then
            progname='risks'
        fi
        local msg="$2"
    else
        local progname="$2"
        local msg="$3"
    fi

    # Padd the program/section name
    progname="$(printf %"${section_padding}"s "${progname}")"

    # Apply any translation for non-english users
    # local i
    # command -v gettext 1>/dev/null 2>/dev/null && msg="$(gettext -s "$3")"
    # for i in {3..${#}}; do
    # 	msg=${(S)msg//::$(($i - 2))*::/$*[$i]}
    # done

    # Apply log chars & color
    local pcolor=${log_colors[$1]}
    local pchars=${log_chars[$1]}

    # Use the display of last message when inline
    [[ "$1" == "inline" ]] && { pcolor=${log_colors[$last_level]}; pchars=${log_chars[inline]} }
    last_level="$1"

    local command="print -P"
    local fd=2
    local -i returncode

    case "$1" in
        inline)
            command+=" -n"
            ;;
        failure)
            returncode=1
            ;;
        print)
            progname=""
            fd=1
            ;;
        # *)
        #     pchars="[F]"; pcolor="red"
        #     msg="Developer oops!  Usage: _msg MESSAGE_TYPE \"MESSAGE_CONTENT\""
        #     returncode=127
        #     ;;
    esac

    [[ -n $_MSG_FD_OVERRIDE ]] && fd=$_MSG_FD_OVERRIDE

    # If there is a log-file specified with flag --log-file,
    # output the message to it, instead of the current file descriptor
    logfile="${args['--log-file']}"
    if [[ -n "${logfile}" ]]; then
        ${=command} "${progname}" "${pchars}" "${msg}" >> "$logfile"
        return $returncode
    fi

    # Else, print to stdout, with colors
    if [[ -t $fd ]]; then
        [[ -n "$progname" ]] && progname="$fg[magenta]$progname$reset_color"
        [[ -n "$pchars" ]] && pchars="$fg_bold[$pcolor]$pchars$reset_color"
        msg="$fg[$pcolor]$msg$reset_color"
    fi

    ${=command} "${progname}" "${pchars}" "${msg}" >&"$fd"
    return $returncode
}

function _info() {
    local notice="message"
    [[ "$1" = "-n" ]] && shift && notice="inline"
    option_is_set -q || _msg "$notice" "$@"
    return 0
}

function _verbose() {
    is_verbose_set && _msg verbose "$@"
    return 0
}

function _success() {
    option_is_set -q || _msg success "$@"
    return 0
}

function _warning() {
    option_is_set -q || _msg warning "$@"
    return 1
}

# failure first prints the message we have passed following the catch
# of an error exit code, and then looks at the contents of erroring
# command's stderr buffer, which is printed just below our message.
# We then exit the program.
function _failure()

{
    typeset -i exitcode=${exitv:-1}

    _msg failure "$@"
    if [[ -n "$COMMAND_STDERR" ]]; then
        _msg inline "$COMMAND_STDERR"
    fi

    # Be sure we forget the secrets we were told
    exit "$exitcode"
}

function _print() {
    option_is_set -q || _msg print "$@"
    return 0
}

# src/lib/mappers.sh
# device.named_mapper_found checks if the "hush partition"

# has been seen by kernel and returns 0 if true.
function device.named_mapper_found ()
{
    ls -1 "/dev/${1}" &> /dev/null
}

# device.luks_mapper_found checks if the "hush partition"

# has been already decrypted and returns 0 if true.
function device.luks_mapper_found ()
{
    ls -1 "/dev/mapper/${1}" &> /dev/null
}

# device.luks_is_opened checks if a luks mapper given

# as argument is opened/unlocked, and returns 0 if true.
# $1 - LUKS device mapper name.
function device.luks_is_opened ()
{
    ls "/dev/mapper/${1}" &> /dev/null
}

# device.luks_is_mounted checks if a luks mapper given

# as argument is mounted, and returns 0 if true.
# $1 - LUKS device mapper name.
function device.luks_is_mounted ()
{
    mount | grep "^${1}" &> /dev/null
}

# device.hush_is_mounted checks if the "hush partition"

# is already mounted and returns 0 if true.
function device.hush_is_mounted ()
{
    mount | grep "^/dev/mapper/${SDCARD_ENC_PART_MAPPER}" &> /dev/null
}

# device.hush_is_rw returns 0 if the hush device mapper

# mount directory has read-write permissions, 1 if not.
function device.hush_is_rw ()
{
    mount | grep "hush" | grep "(rw,relatime)" &> /dev/null
}

# device.is_encrypted_block checks if a *block* device is encrypted.
# Returns 0 if it is an encrypted block device, or 1 if not or failure.
# $1 - /path/to/block/device
function device.is_encrypted_block ()

{
    local	 b=$1 # Path to a block device
    local	 s="" # lsblk option -s (if available)

    # Issue #163
    # lsblk --inverse appeared in util-linux 2.22
    # but --version is not consistent...
    lsblk --help | grep -Fq -- --inverse
    [[ $? -eq 0 ]] && s="--inverse"

    sudo lsblk $s -o type -n "$b" 2>/dev/null \
        | grep -e -q '^crypt$'

    return $?
}

# device.link_hush_udev_rules checks that the udev-rules file that risks
# keeps in its config directory is linked against a file in /etc/udev/rules.d/,
# and if not, echoes this link to the /rw/config/rc.local file.
function device.link_hush_udev_rules ()

{
    # We don't do anything if we don't have a udev-rules file in
    # the risks directory yet.
    if [[ ! -e "$UDEV_RULES_PATH" ]]; then
        return
    fi

    # Or check that a symlink exists, not taking into account

    # the number in the name. If not found:
    if ! ls /etc/udev/rules.d/*"${UDEV_RULES_FILE}" &> /dev/null ; then
        _info "No link to hush udev rules detected, setting it persistent and for this session"

        # - echo the link command into rc.local
        _verbose "Adding the link command to /rw/config/rc.local"
        sudo sh -c 'echo "# The following line was added by the risks CLI, to map hush devices when plugged in this VM" >> /rw/config/rc.local'
        sudo sh -c 'echo "ln -s '"$UDEV_RULES_PATH"' /etc/udev/rules.d/99-risks-hush.rules" >> /rw/config/rc.local'

        # - Create the symlink for this session
        _verbose "Linking the file for this login session"
        sudo ln -s "$UDEV_RULES_PATH" /etc/udev/rules.d/99-risks-hush.rules

        # - reload the udev rules
        _verbose "Reloading udev rules"
        sudo udevadm control --reload-rules
    fi
}

# src/lib/run.sh

COMMAND_STDOUT=''           # Stores a command's stdout output.
COMMAND_STDERR=''           # Stores a command's stderr output.

# do a command, splitting and storing stdout/stderr output and printing
# the former to screen only if the command is ran with verbose flag.
# Returns the command's exit code, so we can catch any errors and inform.
_run ()
{
    # The STDOUT/STDERR variables are populated, which
    # makes their content available to any subsequent call
    # to _failure, which needs STDERR output
    {
        IFS=$'\n' read -r -d '' COMMAND_STDERR;
        IFS=$'\n' read -r -d '' COMMAND_STDOUT;
        (IFS=$'\n' read -r -d '' _ERRNO_; exit "${_ERRNO_}");
    } < <((printf '\0%s\0%d\0' "$("$@")" "${?}" 1>&2) 2>&1)

    local ret="$?"

    # Output the command's result depending on the verbose mode
    # and if the command ran successfully. We check that either
    # stdout or stderr are non-empty: sometimes commands might
    # output to stderr, like wipe.
    if [[ $ret -eq 0 ]] && is_verbose_set ; then
        if [[ -n "$COMMAND_STDOUT" ]]; then
            _verbose "$COMMAND_STDOUT"
        fi
    fi

    # Return the command's exit code
    return $ret
}

# Checks the return code of a command, and if not successful,
# fails with the associated error message. Usage:
# catch $ret "hush" "Failed to execute this command"
function _catch ()
{
    local ret="$?"

    if [[ ! $ret -eq 0 ]]; then
        _failure "$@"
    fi
}

# src/lib/ssh.sh

# ssh.setup generates an SSH keypair and sets up scripts for

# loading multiple keypairs from the identity SSH tomb.
# $1 - Email recipient to use for SSH keypair.
function ssh.setup ()
{
    local email="$1"

    _verbose "Creating and opening tomb file for SSH"
    _run tomb.create "$SSH_TOMB_LABEL" 20 "$IDENTITY"
    _run tomb.open "$SSH_TOMB_LABEL"

    # Write multi-key loading script
    _verbose "Writing multiple SSH-keypairs loading script (ssh-add)"
    cat >"${HOME}/.ssh/ssh-add" <<'EOF'
#!/usr/bin/env bash
#
# Autostart SSH-agent and autoload all private keys in ~/.ssh directory
#
# How to use:
# - Place this scripts in ~/.bashrc. (We did not here, instead we use a .desktop autostart pointing to here).
# - If ssh-agent is not filled by any private keys, passphrase prompts will show up for each private keys
#

# register ssh key
env=~/.ssh/agent.env

agent_load_env () { test -f "$env" && . "$env" >| /dev/null ; }

agent_start () {
(umask 077; ssh-agent >| "$env")
. "$env" >| /dev/null ; }

agent_load_env

# agent_run_state: 0=agent running w/ key; 1=agent w/o key; 2= agent not running
agent_run_state=$(ssh-add -l >| /dev/null 2>&1; echo $?)

if [ ! "$SSH_AUTH_SOCK" ] || [ $agent_run_state = 2 ]; then
agent_start
# this will load all private keys in ~/.ssh directory if agent not running
find ~/.ssh/ -type f -exec grep -l "PRIVATE" {} \; | xargs ssh-add &> /dev/null
elif [ "$SSH_AUTH_SOCK" ] && [ $agent_run_state = 1 ]; then
# this will load all private keys in ~/.ssh directory if agent is not filled with any private key
find ~/.ssh/ -type f -exec grep -l "PRIVATE" {} \; | xargs ssh-add &> /dev/null
fi

unset env
EOF

    # Make the script executable
    chmod +x "${HOME}/.ssh/ssh-add" || _warning "Failed to make ssh-add custom script executable"

    # Generate keys
    _verbose "Generating keys for identity"
    _run ssh-keygen -t ed25519 -b 4096 -C "$email" -N "" -f "${HOME}"/.ssh/id_ed25519 # No passphrase
    _verbose "Making keys immutable"
    sudo chattr +i "${HOME}"/.ssh/id_ed25519*
    _verbose "Closing SSH tomb file"
    _run tomb.close "$SSH_TOMB_LABEL"
}

# get_key_size sets the key size in bits depending
# on the algorithm passed as parameter. If the size
# given as argument is larger than the algo size max,
# the algorithm size maximum is used instead.
# $1 - Algorithm
# $2 - Size to use if possible
# Returns "-b <size" compatible with ssh-keygen
function ssh.set_key_size ()

{
    local algo="${1}"
    local key_size="${2}"
    local max

    # Set max length per key algo

    if [[ "$algo" == "rsa" ]]; then
        max=4096
    elif [[ "$algo" == "ecdsa" ]]; then
        max=384
    elif [[ "$algo" == "dsa" ]]; then
        max=2048
    fi

    # Return the correct size
    [[ -z $max ]] && return
    [[ "${key_size}" -gt "${max}" ]] && print "-b ${max}"
    print "-b ${key_size}"
}

# src/lib/store.sh

# print to stderr, red color
function kv.echo_err ()

{
    echo -e "\e[01;31m$@\e[0m" >&2
}

# Usage: kv_validate_key <key>
function kv.validate_key ()

{
    [[ "$1" =~ ^[0-9a-zA-Z._:-]+$  ]]
}

# Usage: kvget <key>
function kv.get ()

{
    key="$1"
    kv_validate_key "$key" || {
        _failure "db" 'invalid param "key"'
            return 1
        }
        kv_user_dir=${KV_USER_DIR:-$DEFAULT_KV_USER_DIR}
        value="$([ -f "$kv_user_dir/$key" ] && cat "$kv_user_dir/$key")"
        echo "$value"

        [ "$value" != "" ]
    }

# Usage: kvset <key> [value]

function kv.set ()

{
    key="$1"
    value="$2"
    kv_validate_key "$key" || {
        _failure "db" 'invalid param "key"'
            return 1
        }
        kv_user_dir=${KV_USER_DIR:-$DEFAULT_KV_USER_DIR}
        test -d "$kv_user_dir" || mkdir "$kv_user_dir"
        echo "$value" > "$kv_user_dir/$key"
        _info "${key} => ${value}"
    }

# Usage: kvdel <key>
function kv.del ()

{
    key="$1"
    kv_validate_key "$key" || {
        _failure "db" 'invalid param "key"'
            return 1
        }
        kv_user_dir=${KV_USER_DIR:-$DEFAULT_KV_USER_DIR}
        test -f "$kv_user_dir/$key" && rm -f "$kv_user_dir/$key"
        _info "Deleted key '${key}'"
    }

# list all key/value pairs to stdout
# Usage: kvlist
function kv.list ()

{
    kv_user_dir=${KV_USER_DIR:-$DEFAULT_KV_USER_DIR}
    for i in "$kv_user_dir/"*; do
        if [ -f "$i" ]; then
            key="$(basename "$i")"
            echo "$key" "$(kvget "$key")"
        fi
    done

}

# clear all key/value pairs in database
# Usage: kvclear
function kv.clear ()

{
    rm -rf "${KV_USER_DIR:-$DEFAULT_KV_USER_DIR}"
}

# src/lib/tomb.sh

# tomb.get_mapper returns the LUKS mapper of a tomb.
# Returns the mapper name if found, or 'none'.
# $1 - Name of tomb.
function tomb.get_mapper ()
{
    if ls -1 /dev/mapper/tomb.* &> /dev/null ;  then
        ls -1 /dev/mapper/tomb.* | grep "${1}"
    else
        echo "none"
    fi
}

# tomb.create generates a new tomb for a given identity.
# $1 - Name of identity owning the tomb.
# $2 - Size (in megabytes) of the tomb.
function tomb.create ()
{
    local name="$1"
    local size="$2"

    local tomb_label        # Cleartext identifier name of the tomb
    local tomb_file         # Encrypted name of the tomb, for the tomb file itself
    local tomb_file_path    # Absolute path to the tomb file
    local tomb_key          # Encrypted name of the tomb key file
    local tomb_key_path     # Absolute path to the tomb key file
    local uid recipient     # Used to get the email address of the identity with GPG.

    # Filenames
    tomb_label="${IDENTITY}-${name}"
    tomb_file=$(crypt.filename "$tomb_label")

    tomb_key=$(crypt.filename "${tomb_label}.key")
    tomb_key_path="${HUSH_DIR}/${tomb_key}"

    identity_graveyard=$(graveyard.identity_directory "$IDENTITY")
    tomb_file_path="${identity_graveyard}/${tomb_file}.tomb"

    # First make sure GPG keyring is accessible
    _verbose "Opening identity $IDENTITY"
    gpg.open_coffin

    # And get the email recipient
    uid=$(gpg -K | grep uid | head -n 1)
    recipient=$(echo "$uid" | grep -E -o "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}\b")

    # Then dig
    _verbose "Digging tomb in $tomb_file_path"
    tomb dig -s "$size" "$tomb_file_path"

    _catch "Failed to dig tomb. Aborting"
    _run risks_hush_rw_command

    _verbose "Forging tomb key and making it immutable"
    tomb forge -g -r "$recipient" "$tomb_key_path"

    _catch "Failed to forge keys. Aborting"
    sudo chattr +i "$tomb_key_path"

    _verbose "Locking tomb with key"
    tomb lock -g -k "$tomb_key_path" "$tomb_file_path"

    _catch "Failed to lock tomb. Aborting"
    _run risks_hush_ro_command
}

# tomb.delete deletes a tomb in the identity graveyard,
# and its associated key in the hush device.
function tomb.delete ()
{
    local name="$1"

    local tomb_label        # Cleartext identifier name of the tomb
    local tomb_file         # Encrypted name of the tomb, for the tomb file itself
    local tomb_file_path    # Absolute path to the tomb file
    local tomb_key          # Encrypted name of the tomb key file
    local tomb_key_path     # Absolute path to the tomb key file
    local uid recipient     # Used to get the email address of the identity with GPG.

    # Prepare filenames
    tomb_label="${IDENTITY}-${name}"
    tomb_file=$(crypt.filename "$tomb_label")

    tomb_key=$(crypt.filename "${tomb_label}.key")
    tomb_key_path="${HUSH_DIR}/${tomb_key}"

    identity_graveyard=$(graveyard.identity_directory "$IDENTITY")
    tomb_file_path="${identity_graveyard}/${tomb_file}.tomb"

    # A few special cases need confirmation from the user,

    # like GPG, which stores the identity' private keys
    case ${name} in
        GPG)
            _warning "The tomb 'GPG' holds the private keys for this identity !"
            printf >&2 '%s ' 'Do you really want delete this tomb ? (YES/n)'
            read ans

            if [[ "$ans" != 'YES' ]]; then
                _info "Aborting deletion of tomb 'GPG'. Exiting"
                exit 0
            fi
    esac

    # Else we are good to go and delete, even if some files will not be found.
    _info "Deleting tomb $name"

    if [[ -e "$tomb_file_path" ]]; then
        _run wipe -f -r "$tomb_file_path"
    else
        _warning "Tomb file path does not exists, skipping."
    fi

    if [[ -e "$tomb_key_path" ]]; then
        sudo chattr -i "$tomb_key_path"
        _run wipe -f -r -P 10 "$tomb_key_path"
    else

        _warning "Tomb key path does not exists, skipping."
    fi

}

# tomb.open_path accepts an arbitrary tomb path to open.
# $1 - Resource name
# $2 - Tomb file path
# $3 - Tomb key path
function tomb.open_path ()

{
    local resource="${1}"
    local tomb_file_path="${2}"
    local tomb_key_path="${3}"
    local tomb_file="${tomb_file_path:t}"

    mapper=$(tomb.get_mapper "$tomb_file")

    # Some resources need to have fixed mount points,

    # like the few below that are not matched by the wildcard.
    case ${resource} in
        gpg)
            local mount_dir="${HOME}/.gnupg"
            ;;
        pass)
            local mount_dir="${HOME}/.password-store"
            ;;
        ssh)
            local mount_dir="${HOME}/.ssh"
            ;;
        mgmt)
            local mount_dir="${HOME}/.tomb/mgmt"
            ;;
        *)
            local mount_dir="${HOME}/.tomb/${resource}"
            ;;
    esac

    # checks if the gpg coffin is mounted, and open it first:
    # this also have for effect to unlock the identity's graveyard.
    local coffin_name
    coffin_name=$(crypt.filename "coffin-${IDENTITY}-gpg")
    if ! device.luks_is_mounted "/dev/mapper/${coffin_name}" ; then
        gpg.open_coffin
    fi

    if [[ "${mapper}" != "none" ]]; then
        if device.luks_is_mounted "/dev/mapper/tomb.${tomb_file}" ; then
            _verbose "Tomb ${tomb_label} is already open and mounted"
            return 0
        fi
    fi

    if [[ ! -f "$tomb_file_path" ]]; then
        _warning "No tomb file $tomb_file_path found"
        return 2
    fi

    if [[ ! -f "$tomb_key_path" ]]; then
        _warning "No key file $tomb_key_path found"
        return 2
    fi

    # Make the mount point directory if needed
    if [[ ! -d ${mount_dir} ]]; then
        mkdir -p "$mount_dir"
    fi

    # And finally open the tomb
    tomb open -g -k "$tomb_key_path" "$tomb_file_path" "$mount_dir"
    _catch "Failed to open tomb"

    # Either add the only SSH key, or all of them if we have a script
    if [[ "$resource" == "ssh" ]]; then
        local ssh_add_script="${HOME}/.ssh/ssh-add"
        if [[ -e ${ssh_add_script} ]]; then
            ${ssh_add_script}
        else
            ssh-add
        fi
    fi
}

# tomb.open requires a cleartext resource name that the function will encrypt

# to resolve the correct tomb file. The name is both used as a mount directory,

# as well as to determine when some special tombs need to be mounted on non-standard

# mount points, like gpg/ssh.
# $1 - Name of the tomb
function tomb.open ()
{
    local resource="${1}"

    local tomb_label        # Cleartext identifier name of the tomb
    local tomb_file         # Encrypted name of the tomb, for the tomb file itself
    local tomb_file_path    # Absolute path to the tomb file
    local tomb_key          # Encrypted name of the tomb key file
    local tomb_key_path     # Absolute path to the tomb key file
    local mapper            # Mapper name for tomb LUKS filesystem

    # Filenames
    tomb_label="${IDENTITY}-${resource}"
    tomb_file=$(crypt.filename "$tomb_label")

    tomb_key=$(crypt.filename "$tomb_label.key")
    tomb_key_path="${HUSH_DIR}/${tomb_key}"

    identity_graveyard=$(graveyard.identity_directory "$IDENTITY")
    tomb_file_path="${identity_graveyard}/${tomb_file}.tomb"

    # Open the target
    tomb.open_path "${resource}" "${tomb_file_path}" "${tomb_key_path}"
}

# tomb.open_backup opens a target tomb from the

# user backup graveyard instead of the system one.
# This function assumes the backup is accessible.
function tomb.open_backup ()

{
    local resource="${1}"

    local tomb_label        # Cleartext identifier name of the tomb
    local tomb_file         # Encrypted name of the tomb, for the tomb file itself
    local tomb_file_path    # Absolute path to the tomb file
    local tomb_key          # Encrypted name of the tomb key file
    local tomb_key_path     # Absolute path to the tomb key file
    local mapper            # Mapper name for tomb LUKS filesystem

    # Filenames
    tomb_label="${IDENTITY}-${resource}"

    tomb_key=$(crypt.filename "$tomb_label.key")
    tomb_key_path="${HUSH_DIR}/${tomb_key}"

    backup_graveyard="${BACKUP_MOUNT_DIR}/graveyard"
    identity_dir=$(crypt.filename "$IDENTITY")
    identity_graveyard_backup="${backup_graveyard}/${identity_dir}"

    tomb_file=$(crypt.filename "$tomb_label")
    tomb_file_path="${identity_graveyard_backup}/${tomb_file}.tomb"

    # Open the target
    tomb.open_path "${resource}" "${tomb_file_path}" "${tomb_key_path}"
}

# tomb.close attempts to close an open tomb.
function tomb.close ()
{
    local resource="${1}"

    local tomb_label        # Cleartext identifier name of the tomb
    local tomb_file         # Encrypted name of the tomb, for the tomb file itself

    # Filenames
    tomb_label="${IDENTITY}-${resource}"
    tomb_file=$(crypt.filename "${tomb_label}")

    if ! tomb.get_mapper "${tomb_file}" &> /dev/null ; then
        _verbose "Tomb ${IDENTITY}-${resource} is already closed"
        return 0
    fi

    # If the concatenated string is too long, cut it to 16 chars
    if [[ ${#tomb_file} -ge 16 ]]; then
        tomb_file=${tomb_file:0:16}
    fi

    # SSH tombs must all delete all SSH identities from the agent
    if [[ "${resource}" == "ssh" ]]; then
        _run ssh-add -D
    fi

    # Then close it
    tomb close "${tomb_file}"

    # And delete the directory if it's not a builtin
    case ${resource} in
        gpg|pass|ssh|mgmt)
            # Ignore those
            ;;
        *)
            rm -rf "${HOME}/.tomb/${resource}"
            ;;
    esac
}

# tomb.slam is identical to tomb.close, but slamming it,

# so all processes making use of it are killed
function tomb.slam ()
{
    local resource="${1}"

    # Filenames
    # local FULL_name="${IDENTITY}-${resource}"
    tomb_label="${IDENTITY}-${resource}"
    tomb_file=$(crypt.filename "${tomb_label}")

    if ! tomb.get_mapper "${tomb_file}" &> /dev/null ; then
        _verbose "Tomb ${IDENTITY}-${resource} is already closed"
        return 0
    fi

    # If the concatenated string is too long, cut it to 16 chars
    if [[ ${#tomb_file} -ge 16 ]]; then
        tomb_file=${tomb_file:0:16}
    fi

    # SSH tombs must all delete all SSH identities from the agent
    # before tombs kills the process.
    if [[ "${resource}" == "ssh" ]]; then
        _run ssh-add -D
    fi

    # Then close it
    tomb slam "${tomb_file}"

    # And delete the directory if it's not a builtin
    case ${resource} in
        gpg|pass|ssh|mgmt)
            # Ignore those
            ;;
        *)
            rm -rf "${HOME}/.tomb/${resource}"
            ;;
    esac

}

# src/lib/utils.sh

# Return 0 if is set, 1 otherwise
function option_is_set ()

{
    local -i r	 # the return code (0 = set, 1 = unset)

    [[ -n ${(k)OPTS[$1]} ]];
    r=$?

    [[ $2 == "out" ]] && {
        [[ $r == 0 ]] && { print 'set' } || { print 'unset' }
    }

    return $r;
}

# Plays sounds
# Package `sox` provides the "play" program: sudo apt-get install sox
function play_sound ()
{
    if [ ${SDCARD_QUIET} -gt 0 ] || [ ! -x "$(command -v play)" ]; then
        return 1
    fi

    case $1 in

        plugged)
            if [ -f /usr/share/sounds/freedesktop/stereo/device-added.oga ]; then
                play -V0 /usr/share/sounds/freedesktop/stereo/device-added.oga &> /dev/null
            fi
            ;;

        unplugged)

            if [ -f /usr/share/sounds/freedesktop/stereo/device-removed.oga ]; then
                play -V0 /usr/share/sounds/freedesktop/stereo/device-removed.oga &> /dev/null
            fi
            ;;

        *)
            return 1
            ;;
    esac
}

# Retrieves the value of a variable first by looking in the risk
# config file, and optionally overrides it if the flag is set.
# $1 - Flag argument
# $2 - Key name in config
function config_or_flag ()

{
    local value config_value

    config_value=$(config_get $2)   # From config
    value="${1:=$config_value}"      # overriden by flag if set

    print $value
}

# src/lib/validations/format.sh
# validate_file_exists just checks that
validate_file_exists () {
    [[ -e "$1" ]] || echo "Invalid file $1: no such file or directory"
}

# Checks that a partition size given in absolute terms has a valid unit
validate_partition_size () {
    case "$1" in *K|*M|*G|*T|*P) return ;; esac
    echo "Absolute size must comprise a valid unit (K/M/G/T/P, eg. 100M)"
}

# Checks a given device path is encrypted.
validate_is_luks_device () {
    if ! function device.is_encrypted_block  "$1" ; then
        echo "Path $1 seems not to be a LUKS filesystem."
    fi
}

# validate_device is general purpose validator that calls on many of the
# other validations above, because some commands will need all of the
# conditions above to be fulfilled.
validate_device () {

    # Check device file exists
    if [[ ! -e $1 ]]; then
        echo "Device path $1 does not exist: no such file."
    fi
}

# src/lib/validations/identity.sh

# validate_identity_exists simply hashes an identity name and tries to
# find its corresponding coffin file in .graveyard/. If yes, the identity
# exists and is theoretically accessible on this system.
validate_identity_exists () {
    local identity="$1"

    # This might be empty if none have been found, since the _failure
    # call in identity.active_or_specified is executed in a subshell.
    # We don't care.
    IDENTITY=$(identity.active_or_specified "$identity")
    FILE_ENCRYPTION_KEY=$(crypt.set_file_obfs_key "$IDENTITY")

    # Stat the coffin
    local coffin_filename coffin_file
    coffin_filename=$(crypt.filename "${IDENTITY}-gpg.coffin")
    coffin_file="${GRAVEYARD}/${coffin_filename}"

    if [[ ! -e $coffin_file ]]; then
        echo "Invalid identity $1: no corresponding coffin file found in ~/.graveyard"
    fi
}

# :command.command_functions

# :command.function
risks_hush_format_command() {
  # src/hush_format_command.sh

  local sd_drive sd_ext4_drive sd_enc_part mount_point udev_rules uuid

  sd_drive="${args['device']}"        # Device file

  sd_ext4_drive="$sd_drive"1        # Dumb partition
  sd_enc_part="$sd_drive"2          # Encrypted partition
  mount_point="${HUSH_DIR}"

  # Sizes: by default 90% of the drive is used as encrypted partition,
  # but flag --percent-size or --absolute-size can modify size.
  # If absolute size was specified, use it and forget all other values
  if [[ -n "${args['--size-absolute']}" ]]; then
      enc_part_size="${args['--size-absolute']}"
      start_enc_sectors="${enc_part_size}"
  else
      percent_size="${args['--size-percent']}"

      total_size="$(sudo blockdev --getsize "${sd_drive}")"
      enc_part_size="$(( total_size * percent_size / 100 ))"
      start_enc_sectors="$(( total_size - enc_part_size - 2048 ))"
  fi

  # Cleanup & making partitions

  _info "Overwriting and partitioning SDCARD"
  _verbose "Cleaning drive"
  sudo dd if=/dev/urandom of="${sd_drive}" bs=1M status=progress && sync

  _info "Creating partitions"
  hush.format_partitions "$sd_drive" "$start_enc_sectors"
  _catch "Failed to format partitions"

  # Setting up automounting the first partition on any OS

  _verbose "Making 1st partition mountable by default for all OS (fat32)"
  _run sudo mkfs.vfat -F 32 -n DATA "${sd_ext4_drive}"

  _catch "Failed to make vfat32 filesystem"

  # Hush partition encryption setup

  mkdir "${mount_point}" &> /dev/null
  _info "Creating LUKS filesystem"
  sudo cryptsetup -v -q -y --cipher aes-xts-plain64 --key-size 512 --hash sha512 \
      --iter-time 5000 --use-random luksFormat "$sd_enc_part"

  _catch "Failed to format drive with LUKS"

  _verbose "Checking LUKS partition status"
  sudo cryptsetup open --type luks "${sd_enc_part}" "${SDCARD_ENC_PART_MAPPER}"

  _catch "Failed to open LUKS drive"
  _verbose "$(sudo cryptsetup status "${SDCARD_ENC_PART_MAPPER}")"

  # Ext4 with encryption support (for fscrypt) and fscrypt setup
  _info "Making filesytem and setting up high-level encryption (fscrypt)"
  _run sudo mkfs.ext4 -m 0 -L "hush" "/dev/mapper/${SDCARD_ENC_PART_MAPPER}"

  _catch "Failed to make ext4 filesystem on partition"
  _run sudo /sbin/tune2fs -O encrypt "/dev/mapper/${SDCARD_ENC_PART_MAPPER}"

  _catch "Failed to enable encryption on ext4 filesystem"
  _run sudo mount -o rw "/dev/mapper/${SDCARD_ENC_PART_MAPPER}" "${mount_point}"

  _catch "Failed to mount partition on ${mount_point}"

  sudo chown "${USER}" "${HUSH_DIR}"
  _verbose "Setting up fscrypt in hush mount point (${mount_point})"
  sudo fscrypt setup --quiet --force "${mount_point}"
  _catch "Failed to setup fscrypt metadata with root permissions"

  # Checks
  _verbose "$(mount | grep "${SDCARD_ENC_PART_MAPPER}")"
  _verbose "Last command should give the following result:                            \n \
      /dev/mapper/hush on /home/user/.hush type ext4 (rw,relatime,data=ordered)       \n \
      /dev/mapper/hush on /rw/home/user/.hush type ext4 (rw,relatime,data=ordered)    \n\n"

  # Prepare a udev command string with correct UUID, to be written

  # both on this system and on the hush if used on another computer.
  _info "Setting Udev rules for hush partition "

  uuid=$(sudo cryptsetup luksUUID "${sd_enc_part}")
  echo 'SUBSYSTEM=="block", ENV{ID_FS_UUID}=="'"${uuid}"'", SYMLINK+="hush"' >> "${UDEV_RULES_PATH}"

  # Write our risks scripts in a special directory on the hush, and close the device.
  hush.write_risks_scripts "$udev_rules"
  _verbose "Closing and unmounting device"
  _run sudo umount "${mount_point}"

  _catch "Failed to unmount ${mount_point}"

  _run sudo cryptsetup close "${SDCARD_ENC_PART_MAPPER}"

  _catch "Failed to close LUKS filesystem on ${SDCARD_ENC_PART_MAPPER}"

  # Setup udev identitiers mapping for hush partition

  _info "Setting Udev rules for hush partition "

  _catch "Failed to write udev mapper file with SDCard UUID"

  # Create the necessary symbolic links if needed, and reload the rules after creating this link,
  # or simply reload the udev service, to take into account our changes to the udev.
  if ! ls /etc/udev/rules.d/*"${UDEV_RULES_FILE}" &>/dev/null ; then
      device.link_hush_udev_rules
  else
      _verbose "Restarting udev service"

      sudo udevadm control --reload-rules
  fi

  _success "Successfully formatted and prepared SDcard as hush device"
  _success "Please detach the device from the qube for udev rules to work"

}

# :command.function
risks_hush_mount_command() {
  # src/hush_mount_command.sh

  if ! device.named_mapper_found "${SDCARD_ENC_PART_MAPPER}" ; then
      _failure "Device mapper /dev/${SDCARD_ENC_PART_MAPPER} not found.\n\
          Be sure you have attached your hush partition.       "
  fi

  if device.hush_is_mounted ; then
      _info "Sdcard already mounted"
      play_sound
      return 0
  fi

  if ! device.luks_mapper_found "${SDCARD_ENC_PART_MAPPER}" ; then
      # decrypts the "hush partition": it will ask for passphrase
      if ! sudo cryptsetup open --type luks "${SDCARD_ENC_PART}" "${SDCARD_ENC_PART_MAPPER}" ; then
          _failure "The hush partition ${SDCARD_ENC_PART} can not be decrypted"
      fi
  fi

  # creates the "hush partition" mount point if it doesn't exist
  if [ ! -d "${HUSH_DIR}" ]; then
      mkdir -p "${HUSH_DIR}" &> /dev/null
  fi

  # mounts the "hush partition" in read-only mode by default
  if ! sudo mount -o ro "/dev/mapper/${SDCARD_ENC_PART_MAPPER}" "${HUSH_DIR}" ; then
      _failure "/dev/mapper/${SDCARD_ENC_PART_MAPPER} can not be mounted on ${HUSH_DIR}"
  fi

  play_sound "plugged"

  echo
  _success "SDCARD has been mounted read-only. To give write permissions, use:"
  _success "risks hush rw"
  echo

}

# :command.function
risks_hush_rw_command() {
  # src/hush_rw_command.sh
  if ! device.hush_is_mounted ; then
      _failure "SDCARD is not mounted"
      exit 1
  fi

  mount_option="remount,rw"
  if ! sudo mount -o ${mount_option} "/dev/mapper/${SDCARD_ENC_PART_MAPPER}" "${HUSH_DIR}" &> /dev/null ; then
      _failure "/dev/mapper/${SDCARD_ENC_PART_MAPPER} can not be re-mounted with write permissions"
      exit 1
  fi

  sudo chown "${USER}" "${HUSH_DIR}"

  _warning "/----------------------------------------/"
  _info -n "Warning! HUSH is writable              \n"
  _info -n "Do not unplug without umounting it !   \n"
  _info -n "/----------------------------------------/ \n"

}

# :command.function
risks_hush_ro_command() {
  # src/hush_ro_command.sh
  if ! device.hush_is_mounted ; then
      _failure "HUSH is not mounted"
  fi

  mount_option="remount,ro"
  if ! sudo mount -o ${mount_option} "/dev/mapper/${SDCARD_ENC_PART_MAPPER}" "${HUSH_DIR}" &> /dev/null ; then
      _failure "/dev/mapper/${SDCARD_ENC_PART_MAPPER} can not be re-mounted with read-only permissions"
  fi

  _info "HUSH is now mounted read-only"

}

# :command.function
risks_hush_umount_command() {
  # src/hush_umount_command.sh

  # No identity should be active
  if identity.active; then
      _failure "An identity is active, close it first and rerun the command."
  fi

  # Nothing to do if no hush mounted.
  if ! device.named_mapper_found "${SDCARD_ENC_PART_MAPPER}" ; then
      _failure "Device mapper /dev/mapper/${SDCARD_ENC_PART_MAPPER} not found.\n \
          Be sure you have attached your hush partition."
  fi

  # Check there is a hush device mounted
  if device.hush_is_mounted ; then
      if device.hush_is_rw ; then
          _failure "Hush device is currently mounted with read-write permissions. \
              Please ensure not process is writing to it, and mount it read-only."
      fi

      if ! sudo umount -f "${HUSH_DIR}" ; then
          _failure "/dev/mapper/${SDCARD_ENC_PART_MAPPER} can not be umounted from ${HUSH_DIR}"
      fi
  fi

  # Finally try to umount it and close the LUKS filesystem
  if device.luks_mapper_found "${SDCARD_ENC_PART_MAPPER}" ; then
      if ! sudo cryptsetup close "${SDCARD_ENC_PART_MAPPER}" ; then
          _failure "SDCARD can not be closed"
      fi
  fi

  play_sound "unplugged"

  _info "Hush device is unmounted and closed"

}

# :command.function
risks_hush_status_command() {
  # src/hush_status_command.sh

  # Get basic status
  local attached mounted

  attached=$(device.luks_mapper_found "${SDCARD_ENC_PART_MAPPER}")
  mounted=$(device.hush_is_mounted)

  [[ ! $attached -eq 0 ]] && _info "Hush device is not attached to vault qube" && return
  [[ ! $mounted -eq 0 ]] && _info "No hush device mounted" && return

  # Device is mounted, show read-write permissions and mount points.
  _info "Hush device mounts:"
  print "$(mount | grep "^/dev/mapper/${SDCARD_ENC_PART_MAPPER}")"

}

# :command.function
risks_backup_format_command() {
  # src/backup_format_command.sh
  # Easily cleanup, format, luks-encrypt and filesystem setup for a USB drive
  # to be used as a backup medium for risks data.

  pendrive="${args['device']}"

  _info "Formatting and encrypting backup drive"

  # Data cleanup
  _verbose "Overwriting drive data"
  sudo dd if=/dev/urandom of="${pendrive}" bs=1M status=progress && sync

  # Encryption setup
  _info "Setting up LUKS on drive"
  sudo cryptsetup -v -q -y --cipher aes-xts-plain64 --key-size 512 \
      --hash sha512 --iter-time 5000 --use-random luksFormat "${pendrive}"

  _catch "Failed to setup LUKS filesystem on backup drive"

  # Filesystem setup
  mkdir "${BACKUP_MOUNT_DIR}" &> /dev/null
  sudo cryptsetup open --type luks "${pendrive}" "${BACKUP_MAPPER}"

  _catch "Failed to open backup LUKS filesystem"

  _info "Making ext4 filesystem on LUKS mapper"
  _run sudo mkfs.ext4 -m 0 -L "backup" /dev/mapper/"${BACKUP_MAPPER}"

  _catch "Failed to make ext4 filesystem on backup"

  # fsencrypt setup
  _info "Enabling filesystem encryption and setting up fscrypt"
  _run sudo /sbin/tune2fs -O encrypt "/dev/mapper/${BACKUP_MAPPER}"

  _catch "Failed to enable encryption on ext4 filesystem"

  _run sudo mount /dev/mapper/"${BACKUP_MAPPER}" "${BACKUP_MOUNT_DIR}"

  _catch "Failed to mount partition on ${BACKUP_MOUNT_DIR}"
  sudo chown "${USER}" "${BACKUP_MOUNT_DIR}"

  _info "Setting up fscrypt in backup mount point (${BACKUP_MOUNT_DIR})"
  echo "N" | sudo fscrypt setup "${BACKUP_MOUNT_DIR}" &> /dev/null
  _catch "Failed to setup fscrypt metadata with root permissions"

  # Closing
  _info "Unmounting backup pendrive"
  risks_backup_umount_command
  _catch "Failed to correctly unmount backup device"

  _success "Done formatting and encrypting backup drive"
  _success "Use 'risks backup mount' to get read-write access"

}

# :command.function
risks_backup_mount_command() {
  # src/backup_mount_command.sh

  local pendrive="${args['device']}"

  # If we already have a device mounted as backup, fail.
  if ls -1 /dev/mapper/"${BACKUP_MAPPER}" &> /dev/null; then
      _info "Backup device is already mounted"
      play_sound
      return 0
  fi

  if [[ ! -d $BACKUP_MOUNT_DIR ]]; then
      _verbose "Creating mount point directory $BACKUP_MOUNT_DIR"
      mkdir "$BACKUP_MOUNT_DIR" &> /dev/null
      _verbose "Changing directory owner to $USER"
      sudo chown "$USER" "$BACKUP_MOUNT_DIR"
  fi

  _verbose "Opening LUKS pendrive"
  sudo cryptsetup open --type luks "${pendrive}" "$BACKUP_MAPPER"
  _catch "Failed to open LUKS pendrive. Aborting"
  sudo mount /dev/mapper/"${BACKUP_MAPPER}" "$BACKUP_MOUNT_DIR"

  _info "Backup unlocked and mounted on ${BACKUP_MOUNT_DIR}"

}

# :command.function
risks_backup_umount_command() {
  # src/backup_umount_command.sh
  # If identity graveyard backup is unlocked, close it
  if backup.device_unlocked; then
      risks_backup_lock_command
  fi

  if [[ -e "$BACKUP_MOUNT_DIR" ]] ; then
      if ! sudo umount -f "${BACKUP_MOUNT_DIR}" ; then
          _failure "/dev/mapper/${BACKUP_MAPPER} can not be unmounted from ${BACKUP_MOUNT_DIR}"
      fi
  fi

  if device.luks_mapper_found "${BACKUP_MAPPER}" ; then
      if ! sudo cryptsetup close "${BACKUP_MAPPER}" ; then
          _failure "Backup LUKS can not be closed"
      fi
  fi

  play_sound "unplugged"

  _info "Backup device is umounted and closed"

}

# :command.function
risks_backup_unlock_command() {
  # src/backup_unlock_command.sh

  local backup_graveyard          # Where the graveyard root directory is in the backup drive
  local identity_graveyard_backup # Full path to identity graveyard backup
  local identity_dir              # The encrypted graveyard directory for the identity

  identity.set

  backup.fail_device_unmounted
  identity.fail_none_active

  backup_graveyard="${BACKUP_MOUNT_DIR}/graveyard"
  identity_dir=$(crypt.filename "$IDENTITY")
  identity_graveyard_backup="${backup_graveyard}/${identity_dir}"

  # If the identity has no backup, exit.
  if [[ ! -e "$identity_graveyard_backup" ]]; then
      _info "This identity has no graveyard on the backup medium"
      return
  fi

  _info "Unlocking identity graveyard backup"
  crypt.unlock_directory "${identity_graveyard_backup}"

}

# :command.function
risks_backup_lock_command() {
  # src/backup_lock_command.sh

  local backup_graveyard          # Where the graveyard root directory is in the backup drive
  local identity_graveyard_backup # Full path to identity graveyard backup
  local identity_dir              # The encrypted graveyard directory for the identity

  if ! device.luks_mapper_found "$BACKUP_MAPPER" ; then
      _info "No mounted backup medium found."
      return
  fi

  identity.set

  identity.fail_none_active

  backup_graveyard="${BACKUP_MOUNT_DIR}/graveyard"
  identity_dir=$(crypt.filename "$IDENTITY")
  identity_graveyard_backup="${backup_graveyard}/${identity_dir}"

  # If the identity has no backup, exit.
  if [[ ! -e "$identity_graveyard_backup" ]]; then
      _info "This identity has no graveyard on the backup medium"

      return
  fi

  _info "Locking identity graveyard backup"
  crypt.lock_directory "${identity_graveyard_backup}"

}

# :command.function
risks_backup_status_command() {
  # src/backup_status_command.sh

  # Get basic status
  if ! device.luks_mapper_found "${BACKUP_MAPPER}"; then
      _info "No backup device mounted" && return
  fi

  # Device is mounted, show read-write permissions and mount points.
  _info "Backup device mounts:"
  print "$(mount | grep "^/dev/mapper/${BACKUP_MAPPER}")"

  if identity.active; then

      identity.set && echo && _info "Identity backup graveyard status:"

      backup_graveyard="${BACKUP_MOUNT_DIR}/graveyard"
      identity_dir=$(crypt.filename "$IDENTITY")
      identity_graveyard_backup="${backup_graveyard}/${identity_dir}"

      sudo fscrypt status "$identity_graveyard_backup"
  fi

}

# :command.function
risks_backup_identity_command() {
  # src/backup_identity_command.sh

  local backup_graveyard          # Where the graveyard root directory is in the backup drive
  local identity_graveyard        # The full path to the identity system graveyard.
  local identity_graveyard_backup # Full path to identity graveyard backup
  local identity_dir              # The encrypted graveyard directory for the identity

  identity.set

  backup.fail_device_unmounted

  backup_graveyard="${BACKUP_MOUNT_DIR}/graveyard"
  identity_dir=$(crypt.filename "$IDENTITY")
  identity_graveyard="${GRAVEYARD}/${identity_dir}"
  identity_graveyard_backup="${backup_graveyard}/${identity_dir}"

  # Always check that the identity has its own backup directory set up,
  # because backup is not mandatory at identity creation time.
  if [[ ! -e "$identity_graveyard_backup" ]]; then
      _info "Setting graveyard backup for this identity"
      _run backup.setup_identity
      _catch "Failed to setup identity backup graveyard"
  fi

  _info "Backing up current identity data and hush partition"

  echo "$FILE_ENCRYPTION_KEY" | _run sudo fscrypt unlock "$identity_graveyard_backup" --quiet

  # Backup the GPG coffin for this identity
  _verbose "Backing GPG"

  _run backup.write_gpg "${BACKUP_MOUNT_DIR}/graveyard"

  # Graveyard backup for this identity.
  _verbose "Backing graveyard files"
  _run sudo chattr -i "${identity_graveyard_backup}"/* \
      || _verbose "No files in backup/graveyard for which to change immutability properties"

  _run cp -fR "${identity_graveyard}"/* "${identity_graveyard_backup}"
  _catch "Failed to copy graveyard files to backup medium"

  _verbose "Making graveyard backup files immutable"
  _run sudo chattr +i "${identity_graveyard_backup}"/* \
      || _verbose "No files in backup/graveyard for which to change immutability properties"

  # Remove the GPG tomb containing master private and revoc
  backup.move_gpg_master_key

  # Testing the full backup

  _verbose "Printing directory tree in identity backup graveyard"
  _verbose "$(tree "$identity_graveyard_backup")"

  # We don't need the identity backup graveyard anymore, lock it
  _run sudo fscrypt lock "${identity_graveyard_backup}"

  # And backup hush, since it has new content
  risks_backup_hush_command

  _info "Done backing current identity and hush device"

}

# :command.function
risks_backup_hush_command() {
  # src/backup_hush_command.sh

  # if backup is not found, fail and ask to mount
  backup.fail_device_unmounted

  _info "Backing hush partition"

  _verbose "Unmounting hush partition"
  risks_hush_umount_command

  if [[ -e ${BACKUP_MOUNT_DIR}/hush.img ]]; then
      sudo chattr -i "${BACKUP_MOUNT_DIR}"/hush.img
  fi
  sudo dd if=/dev/hush of="${BACKUP_MOUNT_DIR}/hush.img" status=progress bs=16M
  sudo chattr +i "${BACKUP_MOUNT_DIR}/hush.img" || _warning "No hush.img file found after dd operation"

  _info "Done backing hush partition"

}

# :command.function
risks_identity_create_command() {
  # src/identity_create_command.sh

  local name identity expiry pendrive email

  name="${args['name']}"
  name="$(identity.get_args_name "${name}")"
  identity="${name// /_}"
  expiry="$(identity.get_args_expiry "${args['expiry_date']}")"
  email="$(identity.get_args_mail "${name}" "${args['email']}")"
  pendrive="${args['--backup']}" # Backup is optional

  # Checks
  #
  # Ensure no identity and hush is safe to write onto.
  if identity.active ; then
      _failure "An identity seems to be active. Cannot safely create a new one."
  fi

  if device.hush_is_mounted && [[ -w "$HUSH_DIR" ]]; then
      _failure "Hush is currently mounted read-write. \n \
          Please ensure nothing is writing to it and set it to read-only first"
  fi

  _in_section 'risks' 6
  _info "Starting new identity generation process"
  _warning "Do not unplug hush and backup devices during the process"

  _info "Using ${fg_bold[green]}${name}${reset_color} as identity name"
  _info "Using ${fg_bold[green]}${email}${reset_color} as email"

  # Use the identity name to set its file encryption key.
  identity.set "$identity"

  # GPG

  #
  # Generate GPG keypairs with a different passphrase than the one

  # we use for encrypting file/directory names and contents.
  # This passphrase is the one returned by the risks gpg pass command.
  _in_section 'gpg' && _info "Setting up RAMDisk and GPG backend"
  gpg.setup_keyring

  _info "Generating GPG keys"
  GPG_PASS=$(crypt.passphrase "$GPG_TOMB_LABEL")
  echo -n "$GPG_PASS" | xclip -loops 1 -selection clipboard
  _warning "GPG passphrase copied to clipboard with one-time use only"
  _info -n "Paste it in the coming GPG prompt when creating builtin tombs\n"
  _run gpg.generate_keys "$name" "$email" "$expiry"

  # Setup the identity graveyard directory with fscrypt protection
  _in_section 'coffin' && _info "Creating and setting encrypted identity directory"
  graveyard.create

  # At this point, we need access to the hush device in read-write mode.
  _in_section 'hush' && _info "Mounting hush device with read-write permissions"
  risks_hush_mount_command
  _run risks_hush_rw_command

  # Then only, generate the coffin and copy it into the graveyard root directory.
  _in_section 'coffin' && _info "Creating and testing GPG coffin container"
  gpg.generate_coffin

  # Clean RAM disk, remove private keys from the keyring and test open/close

  _in_section 'gpg' && _info "Cleaning and backing keyring privates"
  gpg.cleanup_keyring "$email"

  #
  _in_section 'pass' && _info "Initializing password-store"
  tomb.create_password_store "$email"

  if [[ "${args['--burner']}" -eq 1 ]]; then
      echo && _success "risks" "Identity (burner) generation complete." && echo
      return
  fi

  _in_section 'ssh' && _info "Generating SSH keypair and multi-key ssh-agent script"

  ssh.setup "$email"


  # config files, etc, and set default key=values
  _in_section 'mgmt' && _info "Creating management tomb"
  tomb.create_management

  #
  if [[ -n "$pendrive" ]]; then
      _in_section 'backup' && _info "Setting identity backup and making initial one"

      risks_backup_mount_command
      _catch "failed to decrypt and mount backup drive"

      # Some setup is needed for this identity to have access to its backup
      _verbose "Setting graveyard backup for this identity"
      _run backup.setup_identity
      _catch "Failed to setup identity backup graveyard"

      # And then actually back it up
      risks_backup_identity_command
      _catch "Failed to correctly backup data"

      # Remove the GPG tomb from the user graveyard.
      risks_backup_unlock_command
      backup.move_gpg_master_key
      risks_backup_lock_command

      risks_backup_umount_command
  fi


  echo && _success "risks" "Identity generation complete." && echo

}

# :command.function
risks_identity_open_command() {
  # src/identity_open_command.sh

  identity.set "${args['identity']}"
  hush.fail_device_unmounted

  # Derive the gpg pass phrase from it, with one-time use,
  # needed for all tombs, no matter how many. Only ask for it
  # if it is not yet in the GPG agent cache.
  if ! gpg.passphrase_is_cached ; then
      GPG_PASS=$(crypt.passphrase "$GPG_TOMB_LABEL")
      echo -n "$GPG_PASS" | xclip -loops 1 -selection clipboard
      _warning "GPG passphrase copied to clipboard with one-time use only"
  fi

  _info "Opening coffin and mounting GPG keyring"
  gpg.open_coffin

  _info "Opening Management tomb ... "
  _run tomb.open "$MGMT_TOMB_LABEL"

  _info "Opening SSH tomb ... "
  _run tomb.open "$SSH_TOMB_LABEL"

  _info "Opening PASS tomb ..."
  _run tomb.open "$PASS_TOMB_LABEL"

  _info "Opening Signal tomb ..."
  _run tomb.open "$SIGNAL_TOMB_LABEL"

}

# :command.function
risks_identity_close_command() {
  # src/identity_close_command.sh

  identity.set "${args['identity']}"

  _info "Closing PASS tomb ..."
  _run tomb.close "$PASS_TOMB_LABEL"

  _info "Closing SSH tomb ..."
  _run tomb.close "$SSH_TOMB_LABEL"

  _info "Closing Management tomb ..."
  _run tomb.close "$MGMT_TOMB_LABEL"

  # Finally, find all other tombs...
  tombs=$(tomb list 2>&1 \
      | sed -n '0~4p' \
      | awk -F" " '{print $(3)}' \
      | rev | cut -c2- | rev | cut -c2-)

  # ... and close them
  while read -r tomb_name ; do
      if [[ -z $tomb_name ]]; then
          continue
      fi

      _info "Closing tomb $tomb_name ..."
      _run tomb close "$tomb_name"
  done <<< "$tombs"

  # Close graveyard backup if open
  if device.luks_mapper_found "$BACKUP_MAPPER" ; then
      risks_backup_lock_command
  fi

  _info "Closing GPG coffin ..."
  gpg.close_coffin

}

# :command.function
risks_identity_delete_command() {
  # src/identity_delete_command.sh

  name="${args['name']}"

  hush.fail_device_unmounted

  # If the user wants to delete in the backup, check that a medium is mounted, and fail if not.

  if [[ ${args['--backup']} -eq 1 ]] && ! ls -1 /dev/mapper/"${BACKUP_MAPPER}" &> /dev/null; then
      _failure "User specified to also delete on backup, but none is mounted. \
          Mount one with 'risks backup mount <dev> and rerun this command"
  fi

  # Set the identity variables needed by all functions in this script run,
  # but close the identity itself. We set the resource to delete for this command.

  identity.set "${args['name']}"

  if identity.active && [[ "$(cat "${RISKS_IDENTITY_FILE}")" == "$name" ]]; then
      args["resource"]="identity"
      args["identity"]="$name"
      risks_close_command
  fi

  _info "Starting deletion of identity '$name'"
  _info "Some of the wiping operations will take some time (several minutes). Please wait."

  #  Delete the identity graveyard directory, and the associated fscrypt policy
  _info "Wiping graveyard ($(graveyard.identity_directory "$IDENTITY"))"
  graveyard.delete

  # Delete the coffin files in the graveyard, and coffin key in hush
  _info "Wiping GPG coffin"
  _run risks_hush_rw_command
  gpg.delete_coffin
  _run risks_hush_ro_command

  # Delete the identity graveyard backup.
  if [[ "${args['--backup']}" -eq 1 ]]; then
      backup.delete_identity
  fi

  _info "Deleted identity $name"

}

# :command.function
risks_identity_backup_command() {
  # src/identity_backup_command.sh
  risks_backup_identity_command

}

# :command.function
risks_identity_active_command() {
  # src/identity_active_command.sh
  # Simply print the active identity if there is one
  identity.active_or_specified

}

# :command.function
risks_gpg_generate_command() {
  # src/gpg_generate_command.sh
  local masterkey_available email uid key_algo expiry fingerprint expert

  identity.set ""
  hush.fail_device_unmounted

  if [[ "${args['--sign']}" -eq 0 ]] && [[ "${args['--encrypt']}" -eq 0 ]]; then
      _failure "You must specify either or both of --sign and --encrypt flags for GPG subkeys"
  fi

  key_algo="${args['--algo']-ed25519}"
  expiry="$(identity.get_args_expiry "${args['expiry_date']}")"
  uid=$(gpg -K | grep uid | head -n 1)
  email=$(echo "$uid" | grep -E -o "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}\b")
  masterkey_available="$(gpg.master_key_status)"
  fingerprint=$(gpg -K "${email}" | grep fingerprint | head -n 1 | cut -d= -f2 | sed 's/ //g')
  [[ "${args['--expert']}" -eq 1 ]] && expert="--expert"

  _info "Generating GPG subkey"
  _info "Type: ${key_algo}"
  _info "Signing: ${args['--sign']} | Encrypting: ${args['--encrypt']}"

  _run risks_hush_rw_command

  # Check master private in ring,
  # If not, open tomb and import master key
  if [[ "${masterkey_available}" != true ]]; then
      _info "No master key in keyring, importing from tomb"
      risks_private_import_command
  fi

  GPG_PASS=$(crypt.passphrase "$GPG_TOMB_LABEL")

  if [[ "${args['--interactive']}" -eq 1 ]]; then
      # If user wants to do this interactively, start the GPG prompt.
      _info "Starting GPG prompt for key generation"
      _warning "Copying GPG passphrase to clipboard"
      echo -n "$GPG_PASS" | xclip -selection clipboard
      gpg --edit-key "${fingerprint}" "${expert}"
  else
      # Or generate keys unattended
      gpg.generate_subkeys "${key_algo}" "${fingerprint}" "${expiry}"
  fi

  # Remove master key if was imported
  if [[ $masterkey_available != true ]]; then
      _info "Removing master private key from keyring"
      risks_private_remove_command
  fi

  _run risks_hush_ro_command

  _info "Successfully generated GPG subkey(s)" && return

}

# :command.function
risks_gpg_open_command() {
  # src/gpg_open_command.sh

  identity.set "${args['identity']}"

  # Whatever we need to open, we need the hush device for a key.
  hush.fail_device_unmounted

  _info "Opening coffin and mounting GPG keyring"
  gpg.open_coffin

}

# :command.function
risks_gpg_close_command() {
  # src/gpg_close_command.sh

  identity.set "${args['identity']}"

  _info "Closing coffin and GPG keyring"
  gpg.close_coffin

}

# :command.function
risks_gpg_import_command() {
  # src/gpg_import_command.sh

  local keygrip keypath

  identity.set "${args['identity']}"

  # Hush/backup and identity checks
  hush.fail_device_unmounted
  backup.fail_device_unmounted

  # Open the GPG tomb in the backup, and verify target files are here.
  _run tomb.open_backup "$GPG_TOMB_LABEL"

  keygrip="$(gpg -K | grep Keygrip | head -n 1 | cut -d= -f 2 | sed 's/ //g').key"
  _verbose "Keygrip: $keygrip"
  keypath="${HOME}/.tomb/${GPG_TOMB_LABEL}/${keygrip}"

  if [[ ! -e "${keypath}" ]]; then
      tomb.close "${GPG_TOMB_LABEL}"
      _failure "Private key ${keygrip} not found in ${GPG_TOMB_LABEL} tomb"
  fi

  # Set the hush partition read-write and import the corresponding key
  risks_hush_rw_command

  _info "Importing GPG private key in keyring"
  cp "${keypath}" "${RAMDISK}"/private-keys-v1.d/"${keygrip}"

  _run tomb.close "${GPG_TOMB_LABEL}"

}

# :command.function
risks_gpg_remove_command() {
  # src/gpg_remove_command.sh

  local keygrip keypath

  identity.set "${args['identity']}"

  # Backup/hush and identity checks
  hush.fail_device_unmounted
  backup.fail_device_unmounted

  risks_hush_rw_command

  # Copy/check the private key and revoc certificate, check correcly copied, close GPG tomb
  keygrip="$(gpg -K | grep Keygrip | head -n 1 | cut -d= -f 2 | sed 's/ //g').key"
  _verbose "Keygrip: $keygrip"
  keyring_path="${RAMDISK}/private-keys-v1.d/${keygrip}"

  _info "Wiping private GPG key ${keygrip} from keyring"
  _run wipe -rf "${keyring_path}" \
      || _warning "Failed to delete master private key from keyring !"

  risks_hush_ro_command

  _info "Removed private key from keyring"

}

# :command.function
risks_gpg_pass_command() {
  # src/gpg_pass_command.sh
  # gpg pass essentially wraps a call to spectre with our identity parameters.
  # Note that this function cannot fail because of "a wrong password".
  #
  # If a second, non-nil argument is passed, we print the passphrase:
  # this is used when some commands need both the passphrase as an input
  # to decrypt something (like files) and the user needs them for GPG prompts

  declare timeout

  # Identity is optionality specified as an argument
  identity.set "${args['identity']}"

  # Since we did not give any input (master) passphrase to this call,
  # spectre will prompt us for an input one. This input is already known
  # to us, since we have used the same when generating the GPG keys.
  #
  # In addition: this call cannot fail because of "a wrong" passphrase.
  # It will just output something, which will or will not (if actually incorrect)
  # work when pasted in further GPG passphrase prompts.
  GPG_PASS=$(crypt.passphrase "$GPG_TOMB_LABEL")

  timeout="${args['--timeout']-$GPGPASS_TIMEOUT}"

  echo -n "$GPG_PASS" | xclip -selection clipboard
  ( sleep "$timeout"; echo -n "" | xclip -selection clipboard;) &

  _info "The passphrase has been saved in clipboard"
  _info "Press CTRL+SHIFT+C to share the clipboard with another qube."
  _info "Local clipboard will be erased is $timeout seconds"

}

# :command.function
risks_ssh_generate_command() {
  # src/ssh_generate_command.sh

  local email uid ssh_key_name key_algo

  identity.set ""
  hush.fail_device_unmounted

  # Parameters setup
  key_algo="${args['--algo']-ed25519}"
  uid=$(gpg -K | grep uid | head -n 1)
  email=$(echo "$uid" | grep -E -o "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}\b")
  bits="$(get_key_size "${key_algo}" "${args['--bits']}")"

  ssh_key_name="${args['--filename']}"
  [[ -z ${ssh_key_name} ]] && ssh_key_name="${IDENTITY}-${key_algo}-${RANDOM}"

  # Generation
  _info "Generating SSH keypair"
  _info "Type: ${key_algo}"

  _run tomb.open "$SSH_TOMB_LABEL"

  ssh-keygen -t "${key_algo}" "${bits}" -C "$email" -N "" -f "${HOME}"/.ssh/"${ssh_key_name}"
  _catch "Failed to generate SSH keys"

  _verbose "Making keys immutable"
  sudo chattr +i "${HOME}"/.ssh/"${ssh_key_name}"*

  _info "Successfully generated new SSH keypair" && return

}

# :command.function
risks_tomb_create_command() {
  # src/tomb_create_command.sh

  label="${args['tomb_name']}"
  size="${args['size']}"

  hush.fail_device_unmounted
  identity.set "${args["identity"]}"

  _info "Creating tomb $label with size ${size}M"

  # This new key is also the one provided when using gpgpass command.
  GPG_PASS=$(crypt.passphrase "$GPG_TOMB_LABEL")
  echo -n "$GPG_PASS" | xclip -loops 1 -selection clipboard
  _warning "GPG passphrase copied to clipboard with one-time use only"
  _info -n "Copy it in the coming GPG prompt when creating the tomb.\n"

  _run tomb.create "$label" "$size"
  _catch "Failed to create tomb"

  _info "Done creating tomb."

}

# :command.function
risks_tomb_open_command() {
  # src/tomb_open_command.sh

  resource="${args['resource']}"

  identity.set "${args['identity']}"
  hush.fail_device_unmounted

  # Derive the gpg pass phrase from it, with one-time use,
  # needed for all tombs, no matter how many. Only ask for it
  # if it is not yet in the GPG agent cache.
  if ! gpg.passphrase_is_cached ; then
      GPG_PASS=$(crypt.passphrase "$GPG_TOMB_LABEL")
      echo -n "$GPG_PASS" | xclip -loops 1 -selection clipboard
      _warning "GPG passphrase copied to clipboard with one-time use only"
  fi

  _run tomb.open "$resource"

}

# :command.function
risks_tomb_close_command() {
  # src/tomb_close_command.sh

  resource="${args['resource']}"

  identity.set "${args['identity']}"

  tomb.close "$resource"
  exit $?

}

# :command.function
risks_tomb_delete_command() {
  # src/tomb_delete_command.sh

  name="${args['tomb_name']}"

  hush.fail_device_unmounted

  # Check the backup medium is here if asked to delete it also.
  if [[ "${args['--backup']}" -eq 1 ]]; then
      backup.fail_device_unmounted
  fi

  identity.set "${args['identity']}"

  # Delete tomb in graveyard and key in hush.
  _run risks_hush_rw_command
  tomb.delete "$name"
  _run risks_hush_ro_command

  # Delete in backup if specified
  if [[ "${args['--backup']}" -eq 1 ]]; then
      _info "Deleting tomb backup"
      backup.tomb_delete "$name"
  fi

  _info "Deleted tomb $name"

}

# :command.function
risks_list_command() {
  # src/list_command.sh

  resource="${args['resource']}"

  if [[ -z $resource ]]; then
      gpg.list_coffins
      echo
      _info "Tombs currently opened:"
      tomb list
      exit $?
  fi

  if [[ "${resource}" == "coffins" ]]; then
      gpg.list_coffins
      exit $?
  fi

  if [[ "${resource}" == "tombs" ]]; then
      _info "Tombs currently opened:"
      tomb list
      exit $?
  fi

  _failure "Unknown resource ${resource}"

}

# :command.function
risks_slam_command() {
  # src/slam_command.sh

  # First set the identity variables with the active one.

  identity.set ""

  _warning "risks" "Slaming identity $IDENTITY"

  _info "Slaming PASS tomb ..."
  _run tomb.slam "$PASS_TOMB_LABEL"

  _info "Slaming SSH tomb ..."
  _run tomb.slam "$SSH_TOMB_LABEL"

  _info "Slaming Management tomb ..."
  _run tomb.slam "$MGMT_TOMB_LABEL"

  _info "Closing GPG coffin ..."
  gpg.close_coffin
  # done

  # Finally, find all other tombs...
  tombs=$(tomb list 2>&1 \
      | sed -n '0~4p' \
      | awk -F" " '{print $(3)}' \
      | rev | cut -c2- | rev | cut -c2-)

  # ... and close them
  while read -r tomb_name ; do
      if [[ -z $tomb_name ]]; then
          continue
      fi

      _info "Slaming tomb $tomb_name ..."
      _run tomb slam "$tomb_name"
  done <<< "$tombs"

  # Close graveyard backup if open
  if device.luks_mapper_found "$BACKUP_MAPPER" ; then
      risks_backup_lock_command
  fi

  # 3 - Unmount hush and backup
  echo
  _info "Unmounting hush partition"
  _run risks_hush_umount_command
  _catch "Failed to unmount hush partition"

  _info "Umounting backup device"
  _run risks_backup_umount_command
  _catch "Failed to umount backup device"

}

# :command.function
risks_cleanup_command() {
  # src/cleanup_command.sh

  if identity.active; then
      _info "An identity is active, closing it before cleanup."
      risks_identity_close_command
      echo
  fi

  _warning "Unmounting orphaned file systems and devices"
  _info "Unmounting .gnupg ramdisk"
  _info "Unmounting /tmp/${BACKUP_MAPPER}"

  _warning "Deleting directories"
  _info "Wiping .gnupg/"
  _info "Wiping .ssh/"
  _info "Wiping .tomb/"

  _success "Done cleaning vault system"

}

# :command.function
risks_load_command() {
  # src/load_command.sh

  local resource dest_vm source_dir

  resource="${args['resource']}"   # Resource is a tomb file (root directory) in ~/.tomb
  dest_vm="${args['dest_vm']}"

  identity.set "${args['identity']}"

  # Open the related tomb for the tool

  _run tomb.open "$resource"
  _catch "Failed to open tomb"

  # Get the source directory, and copy the files to the VM
  _info "Loading data in tomb $resource to VM $dest_vm"
  source_dir="${HOME}/.tomb/${resource}"
  _info "$(qvm-copy-to-vm "$dest_vm" "${source_dir}/"'*')"

  # And close tomb if asked to
  if [[ "${args['--close-tomb']}" -eq 1 ]]; then
      _info "Closing tomb"
      _run tomb.close "$resource"
  fi

}

# :command.function
risks_save_command() {
  # src/save_command.sh

  local source_vm resource source_dir dest_dir

  source_vm="${args['source_vm']}"

  resource="${args['resource']}"   # Resource is a tomb file (root directory) in ~/.tomb

  identity.set "${args['identity']}"

  # Make the source directory

  # Don't do anything if the directory does not exist
  source_dir="${HOME}/QubesIncoming/${source_vm}"
  if [[ ! -d $source_dir ]]; then
      _failure "No QubesIncoming directory found for $source_vm"
  fi

  # Open the related tomb for the tool

  _run tomb.open "$resource"
  _catch "Failed to open tomb"

  # And make the destination directory
  dest_dir="${HOME}/.tomb/${resource}"

  # Or move the data from the directory to the tomb directory
  _info "Moving data to tomb $resource directory"
  mv "${source_dir}/"'*' "$dest_dir"

  # And close tomb if asked to
  if [[ "${args['--close-tomb']}" -eq 1 ]]; then
      _info "Closing tomb"
      _run tomb.close "$resource"
  fi

}

# :command.function
risks_resolve_coffin_command() {
  # src/resolve_coffin_command.sh

  identity.set "${args['identity']}"

  coffin_filename=$(crypt.filename "${IDENTITY}-gpg.coffin")
  print "${GRAVEYARD}/${coffin_filename}"

}

# :command.function
risks_resolve_tomb_command() {
  # src/resolve_tomb_command.sh

  local tomb_file tomb_label resource

  identity.set ""

  resource="${args['tomb_name']}"
  tomb_label="${IDENTITY}-${resource}"

  identity_graveyard=$(graveyard.identity_directory "$IDENTITY")
  tomb_file=$(crypt.filename "$tomb_label")

  print "${identity_graveyard}/${tomb_file}.tomb"

}

# :command.function
risks_resolve_key_command() {
  # src/resolve_key_command.sh

  local tomb_key tomb_label

  identity.set "${args['identity']}"

  resource="${args['tomb_name']}"
  tomb_label="${IDENTITY}-${resource}"

  tomb_key=$(crypt.filename "$tomb_label.key")
  print "${HUSH_DIR}/${tomb_key}"

}

# :command.function
risks_config_set_command() {
  # src/config_set_command.sh

  local key value

  key="${args['key']}"
  value="${args['value']}"

  config_set "$key" "$value"

}

# :command.function
risks_config_get_command() {
  # src/config_get_command.sh

  local key

  key="${args['key']}"

  config_get "$key"

}

# :command.function
risks_config_unset_command() {
  # src/config_unset_command.sh

  local key

  key="${args['key']}"

  config_set "$key" ""

}

# :command.function
risks_config_list_command() {
  # src/config_list_command.sh
  config_show

}

# :command.function
risks_config_keys_command() {
  # src/config_keys_command.sh
  config_keys

}

# :command.function
risks_kv_set_command() {
  # src/kv_set_command.sh
  key="${args['key']}"
  value="${args['value']}"

  kvset "${key}" "${value}"

}

# :command.function
risks_kv_get_command() {
  # src/kv_get_command.sh
  key="${args['key']}"

  kvget "${key}"

}

# :command.function
risks_kv_unset_command() {
  # src/kv_unset_command.sh
  key="${args['key']}"

  kvdel "${key}"

}

# :command.function
risks_kv_list_command() {
  # src/kv_list_command.sh
  _info "Saved keys:"

  kvlist

}

# :command.function
risks_kv_clean_command() {
  # src/kv_clean_command.sh
  _info "Clearing all keys for the store"

  kvclear

}

# :command.function
risks_help_command() {
  # src/help_command.sh
  command="${args['command']}"
  long_usage=yes

  if [[ -z "$command" ]]; then
    # No command argument, show the global help
    help_function=risks_usage
  else
    # Show the help for the requested command
    help_function="risks_${command}_usage"
  fi

  # Call the help function if it exists
  if [[ $(type "$help_function") ]]; then
    "$help_function"
  else
    echo "No help available for this command"
    exit 1
  fi

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        risks_usage
        exit
        ;;

      # :flag.case
      --verbose | -v)

        # :flag.case_no_arg
        args['--verbose']=1
        shift
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if ! command -v wipe >/dev/null 2>&1; then
    printf "missing dependency: wipe\n" >&2
    exit 1
  fi

  if ! command -v tomb >/dev/null 2>&1; then
    printf "missing dependency: tomb\n" >&2
    exit 1
  fi

  if ! command -v fscrypt >/dev/null 2>&1; then
    printf "missing dependency: fscrypt\n" >&2
    exit 1
  fi

  if ! command -v steghide >/dev/null 2>&1; then
    printf "missing dependency: steghide\n" >&2
    exit 1
  fi

  if ! command -v spectre >/dev/null 2>&1; then
    printf "missing dependency: spectre\n" >&2
    exit 1
  fi

  if ! command -v pass >/dev/null 2>&1; then
    printf "missing dependency: pass\n" >&2
    exit 1
  fi

  if ! command -v gpg2 >/dev/null 2>&1; then
    printf "missing dependency: gpg2\n" >&2
    exit 1
  fi

  if ! command -v xclip >/dev/null 2>&1; then
    printf "missing dependency: xclip\n" >&2
    exit 1
  fi

  if ! command -v socat >/dev/null 2>&1; then
    printf "missing dependency: socat\n" >&2
    exit 1
  fi

  if ! command -v pinentry-curses >/dev/null 2>&1; then
    printf "missing dependency: pinentry-curses\n" >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    hush)
      action="hush"
      shift
      risks_hush_parse_requirements "$@"
      shift $#
      ;;

    backup)
      action="backup"
      shift
      risks_backup_parse_requirements "$@"
      shift $#
      ;;

    identity)
      action="identity"
      shift
      risks_identity_parse_requirements "$@"
      shift $#
      ;;

    gpg)
      action="gpg"
      shift
      risks_gpg_parse_requirements "$@"
      shift $#
      ;;

    ssh)
      action="ssh"
      shift
      risks_ssh_parse_requirements "$@"
      shift $#
      ;;

    tomb)
      action="tomb"
      shift
      risks_tomb_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      risks_list_parse_requirements "$@"
      shift $#
      ;;

    slam)
      action="slam"
      shift
      risks_slam_parse_requirements "$@"
      shift $#
      ;;

    cleanup)
      action="cleanup"
      shift
      risks_cleanup_parse_requirements "$@"
      shift $#
      ;;

    load)
      action="load"
      shift
      risks_load_parse_requirements "$@"
      shift $#
      ;;

    save)
      action="save"
      shift
      risks_save_parse_requirements "$@"
      shift $#
      ;;

    resolve)
      action="resolve"
      shift
      risks_resolve_parse_requirements "$@"
      shift $#
      ;;

    config)
      action="config"
      shift
      risks_config_parse_requirements "$@"
      shift $#
      ;;

    kv)
      action="kv"
      shift
      risks_kv_parse_requirements "$@"
      shift $#
      ;;

    help)
      action="help"
      shift
      risks_help_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risks_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_hush_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_hush_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    format)
      action="format"
      shift
      risks_hush_format_parse_requirements "$@"
      shift $#
      ;;

    mount)
      action="mount"
      shift
      risks_hush_mount_parse_requirements "$@"
      shift $#
      ;;

    rw)
      action="rw"
      shift
      risks_hush_rw_parse_requirements "$@"
      shift $#
      ;;

    ro)
      action="ro"
      shift
      risks_hush_ro_parse_requirements "$@"
      shift $#
      ;;

    umount)
      action="umount"
      shift
      risks_hush_umount_parse_requirements "$@"
      shift $#
      ;;

    status)
      action="status"
      shift
      risks_hush_status_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risks_hush_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_hush_format_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_hush_format_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="hush format"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --size-percent | -P)
        # :flag.conflicts
        if [[ -n "${args['--size-absolute']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--size-absolute" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--size-percent']="$2"
          shift
          shift
        else
          printf "%s\n" "--size-percent requires an argument: --size-percent, -P PERCENT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --size-absolute | -A)
        # :flag.conflicts
        if [[ -n "${args['--size-percent']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--size-percent" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          # :flag.validations
          if [[ -n $(validate_partition_size "$2") ]]; then
            printf "validation error in %s:\n%s\n" "--size-absolute, -A SIZE" "$(validate_partition_size "$2")" >&2
            exit 1
          fi

          args['--size-absolute']="$2"
          shift
          shift
        else
          printf "%s\n" "--size-absolute requires an argument: --size-absolute, -A SIZE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['device']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_file_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "DEVICE" "$(validate_file_exists "$1")" >&2
            exit 1
          fi

          args['device']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['device']+x} ]]; then
    printf "missing required argument: DEVICE\nusage: risks hush format DEVICE [OPTIONS]\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--size-percent']:-} ]] || args['--size-percent']="90"

}

# :command.parse_requirements
risks_hush_mount_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_hush_mount_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="hush mount"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_hush_rw_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_hush_rw_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="hush rw"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_hush_ro_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_hush_ro_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="hush ro"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_hush_umount_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_hush_umount_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="hush umount"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_hush_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_hush_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="hush status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_backup_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_backup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    format)
      action="format"
      shift
      risks_backup_format_parse_requirements "$@"
      shift $#
      ;;

    mount)
      action="mount"
      shift
      risks_backup_mount_parse_requirements "$@"
      shift $#
      ;;

    umount)
      action="umount"
      shift
      risks_backup_umount_parse_requirements "$@"
      shift $#
      ;;

    unlock)
      action="unlock"
      shift
      risks_backup_unlock_parse_requirements "$@"
      shift $#
      ;;

    lock)
      action="lock"
      shift
      risks_backup_lock_parse_requirements "$@"
      shift $#
      ;;

    status)
      action="status"
      shift
      risks_backup_status_parse_requirements "$@"
      shift $#
      ;;

    identity)
      action="identity"
      shift
      risks_backup_identity_parse_requirements "$@"
      shift $#
      ;;

    hush)
      action="hush"
      shift
      risks_backup_hush_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risks_backup_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_backup_format_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_backup_format_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="backup format"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['device']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_file_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "DEVICE" "$(validate_file_exists "$1")" >&2
            exit 1
          fi

          args['device']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['device']+x} ]]; then
    printf "missing required argument: DEVICE\nusage: risks backup format DEVICE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_backup_mount_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_backup_mount_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="backup mount"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['device']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_file_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "DEVICE" "$(validate_file_exists "$1")" >&2
            exit 1
          fi

          args['device']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['device']+x} ]]; then
    printf "missing required argument: DEVICE\nusage: risks backup mount DEVICE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_backup_umount_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_backup_umount_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="backup umount"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_backup_unlock_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_backup_unlock_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="backup unlock"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_identity_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")" >&2
            exit 1
          fi

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risks backup unlock IDENTITY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_backup_lock_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_backup_lock_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="backup lock"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_backup_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_backup_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="backup status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_backup_identity_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_backup_identity_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="backup identity"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --log-file | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--log-file']="$2"
          shift
          shift
        else
          printf "%s\n" "--log-file requires an argument: --log-file, -f LOGFILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_identity_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")" >&2
            exit 1
          fi

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risks_backup_hush_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_backup_hush_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="backup hush"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_identity_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_identity_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    create)
      action="create"
      shift
      risks_identity_create_parse_requirements "$@"
      shift $#
      ;;

    open)
      action="open"
      shift
      risks_identity_open_parse_requirements "$@"
      shift $#
      ;;

    close)
      action="close"
      shift
      risks_identity_close_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      risks_identity_delete_parse_requirements "$@"
      shift $#
      ;;

    backup)
      action="backup"
      shift
      risks_identity_backup_parse_requirements "$@"
      shift $#
      ;;

    active)
      action="active"
      shift
      risks_identity_active_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risks_identity_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_identity_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_identity_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --backup | -b)

        # :flag.case_no_arg
        args['--backup']=1
        shift
        ;;

      # :flag.case
      --burner | -B)

        # :flag.case_no_arg
        args['--burner']=1
        shift
        ;;

      # :flag.case
      --mail | -m)

        # :flag.case_no_arg
        args['--mail']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['name']+x} ]]; then

          args['name']=$1
          shift
        elif [[ -z ${args['email']+x} ]]; then

          args['email']=$1
          shift
        elif [[ -z ${args['expiry_date']+x} ]]; then

          args['expiry_date']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risks_identity_open_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_identity_open_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity open"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_identity_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")" >&2
            exit 1
          fi

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risks identity open IDENTITY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_identity_close_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_identity_close_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity close"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_identity_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")" >&2
            exit 1
          fi

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risks_identity_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_identity_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --backup | -b)

        # :flag.case_no_arg
        args['--backup']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['name']+x} ]]; then

          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: risks identity delete NAME [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_identity_backup_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_identity_backup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity backup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_identity_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")" >&2
            exit 1
          fi

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risks_identity_active_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_identity_active_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="identity active"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_gpg_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_gpg_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    generate)
      action="generate"
      shift
      risks_gpg_generate_parse_requirements "$@"
      shift $#
      ;;

    open)
      action="open"
      shift
      risks_gpg_open_parse_requirements "$@"
      shift $#
      ;;

    close)
      action="close"
      shift
      risks_gpg_close_parse_requirements "$@"
      shift $#
      ;;

    import)
      action="import"
      shift
      risks_gpg_import_parse_requirements "$@"
      shift $#
      ;;

    remove)
      action="remove"
      shift
      risks_gpg_remove_parse_requirements "$@"
      shift $#
      ;;

    pass)
      action="pass"
      shift
      risks_gpg_pass_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risks_gpg_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_gpg_generate_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_gpg_generate_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="gpg generate"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --sign | -S)

        # :flag.case_no_arg
        args['--sign']=1
        shift
        ;;

      # :flag.case
      --encrypt | -E)

        # :flag.case_no_arg
        args['--encrypt']=1
        shift
        ;;

      # :flag.case
      --interactive | -i)

        # :flag.case_no_arg
        args['--interactive']=1
        shift
        ;;

      # :flag.case
      --expert | -e)

        # :flag.case_no_arg
        args['--expert']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['algo']+x} ]]; then

          args['algo']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risks_gpg_open_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_gpg_open_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="gpg open"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_identity_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")" >&2
            exit 1
          fi

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risks gpg open IDENTITY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_gpg_close_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_gpg_close_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="gpg close"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_identity_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")" >&2
            exit 1
          fi

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risks_gpg_import_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_gpg_import_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="gpg import"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_identity_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")" >&2
            exit 1
          fi

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['identity']+x} ]]; then
    printf "missing required argument: IDENTITY\nusage: risks gpg import IDENTITY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_gpg_remove_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_gpg_remove_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="gpg remove"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_gpg_pass_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_gpg_pass_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="gpg pass"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --timeout | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--timeout']="$2"
          shift
          shift
        else
          printf "%s\n" "--timeout requires an argument: --timeout, -t TIMEOUT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['identity']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_identity_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")" >&2
            exit 1
          fi

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--timeout']:-} ]] || args['--timeout']="45"

}

# :command.parse_requirements
risks_ssh_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_ssh_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    generate)
      action="generate"
      shift
      risks_ssh_generate_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risks_ssh_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_ssh_generate_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_ssh_generate_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="ssh generate"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --bits | -b)

        # :flag.case_no_arg
        args['--bits']=1
        shift
        ;;

      # :flag.case
      --filename | -f)

        # :flag.case_no_arg
        args['--filename']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['algo']+x} ]]; then

          args['algo']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risks_tomb_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_tomb_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    create)
      action="create"
      shift
      risks_tomb_create_parse_requirements "$@"
      shift $#
      ;;

    open)
      action="open"
      shift
      risks_tomb_open_parse_requirements "$@"
      shift $#
      ;;

    close)
      action="close"
      shift
      risks_tomb_close_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      risks_tomb_delete_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risks_tomb_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_tomb_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_tomb_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tomb create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['tomb_name']+x} ]]; then

          args['tomb_name']=$1
          shift
        elif [[ -z ${args['size']+x} ]]; then

          args['size']=$1
          shift
        elif [[ -z ${args['identity']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_identity_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")" >&2
            exit 1
          fi

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['tomb_name']+x} ]]; then
    printf "missing required argument: TOMB_NAME\nusage: risks tomb create TOMB_NAME SIZE [IDENTITY]\n" >&2
    exit 1
  fi
  if [[ -z ${args['size']+x} ]]; then
    printf "missing required argument: SIZE\nusage: risks tomb create TOMB_NAME SIZE [IDENTITY]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_tomb_open_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_tomb_open_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tomb open"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['resource']+x} ]]; then

          args['resource']=$1
          shift
        elif [[ -z ${args['identity']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_identity_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")" >&2
            exit 1
          fi

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['resource']+x} ]]; then
    printf "missing required argument: RESOURCE\nusage: risks tomb open RESOURCE [IDENTITY]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_tomb_close_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_tomb_close_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tomb close"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['resource']+x} ]]; then

          args['resource']=$1
          shift
        elif [[ -z ${args['identity']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_identity_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")" >&2
            exit 1
          fi

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['resource']+x} ]]; then
    printf "missing required argument: RESOURCE\nusage: risks tomb close RESOURCE [IDENTITY]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_tomb_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_tomb_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tomb delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --backup | -b)

        # :flag.case_no_arg
        args['--backup']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['tomb_name']+x} ]]; then

          args['tomb_name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['tomb_name']+x} ]]; then
    printf "missing required argument: TOMB_NAME\nusage: risks tomb delete TOMB_NAME [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['resource']+x} ]]; then

          args['resource']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risks_slam_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_slam_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="slam"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_cleanup_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_cleanup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="cleanup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_load_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_load_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="load"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --close-tomb | -c)

        # :flag.case_no_arg
        args['--close-tomb']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['resource']+x} ]]; then

          args['resource']=$1
          shift
        elif [[ -z ${args['dest_vm']+x} ]]; then

          args['dest_vm']=$1
          shift
        elif [[ -z ${args['identity']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_identity_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")" >&2
            exit 1
          fi

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['resource']+x} ]]; then
    printf "missing required argument: RESOURCE\nusage: risks load RESOURCE DEST_VM [IDENTITY] [OPTIONS]\n" >&2
    exit 1
  fi
  if [[ -z ${args['dest_vm']+x} ]]; then
    printf "missing required argument: DEST_VM\nusage: risks load RESOURCE DEST_VM [IDENTITY] [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_save_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_save_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="save"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --close-tomb | -c)

        # :flag.case_no_arg
        args['--close-tomb']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['source_vm']+x} ]]; then

          args['source_vm']=$1
          shift
        elif [[ -z ${args['resource']+x} ]]; then

          args['resource']=$1
          shift
        elif [[ -z ${args['identity']+x} ]]; then
          # :argument.validations
          if [[ -n $(validate_identity_exists "$1") ]]; then
            printf "validation error in %s:\n%s\n" "IDENTITY" "$(validate_identity_exists "$1")" >&2
            exit 1
          fi

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['source_vm']+x} ]]; then
    printf "missing required argument: SOURCE_VM\nusage: risks save SOURCE_VM RESOURCE [IDENTITY] [OPTIONS]\n" >&2
    exit 1
  fi
  if [[ -z ${args['resource']+x} ]]; then
    printf "missing required argument: RESOURCE\nusage: risks save SOURCE_VM RESOURCE [IDENTITY] [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_resolve_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_resolve_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    coffin)
      action="coffin"
      shift
      risks_resolve_coffin_parse_requirements "$@"
      shift $#
      ;;

    tomb)
      action="tomb"
      shift
      risks_resolve_tomb_parse_requirements "$@"
      shift $#
      ;;

    key)
      action="key"
      shift
      risks_resolve_key_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risks_resolve_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_resolve_coffin_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_resolve_coffin_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="resolve coffin"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['name']+x} ]]; then

          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
risks_resolve_tomb_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_resolve_tomb_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="resolve tomb"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['tomb_name']+x} ]]; then

          args['tomb_name']=$1
          shift
        elif [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['tomb_name']+x} ]]; then
    printf "missing required argument: TOMB_NAME\nusage: risks resolve tomb TOMB_NAME [IDENTITY]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_resolve_key_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_resolve_key_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="resolve key"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['tomb_name']+x} ]]; then

          args['tomb_name']=$1
          shift
        elif [[ -z ${args['identity']+x} ]]; then

          args['identity']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['tomb_name']+x} ]]; then
    printf "missing required argument: TOMB_NAME\nusage: risks resolve key TOMB_NAME [IDENTITY]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_config_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_config_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    set)
      action="set"
      shift
      risks_config_set_parse_requirements "$@"
      shift $#
      ;;

    get)
      action="get"
      shift
      risks_config_get_parse_requirements "$@"
      shift $#
      ;;

    unset)
      action="unset"
      shift
      risks_config_unset_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      risks_config_list_parse_requirements "$@"
      shift $#
      ;;

    keys)
      action="keys"
      shift
      risks_config_keys_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risks_config_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_config_set_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_config_set_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config set"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        elif [[ -z ${args['value']+x} ]]; then

          args['value']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: risks config set KEY VALUE\n" >&2
    exit 1
  fi
  if [[ -z ${args['value']+x} ]]; then
    printf "missing required argument: VALUE\nusage: risks config set KEY VALUE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_config_get_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_config_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: risks config get KEY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_config_unset_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_config_unset_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config unset"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: risks config unset KEY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_config_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_config_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_config_keys_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_config_keys_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config keys"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_kv_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_kv_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    set)
      action="set"
      shift
      risks_kv_set_parse_requirements "$@"
      shift $#
      ;;

    get)
      action="get"
      shift
      risks_kv_get_parse_requirements "$@"
      shift $#
      ;;

    unset)
      action="unset"
      shift
      risks_kv_unset_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      risks_kv_list_parse_requirements "$@"
      shift $#
      ;;

    clean)
      action="clean"
      shift
      risks_kv_clean_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      risks_kv_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_kv_set_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_kv_set_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="kv set"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        elif [[ -z ${args['value']+x} ]]; then

          args['value']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: risks kv set KEY VALUE\n" >&2
    exit 1
  fi
  if [[ -z ${args['value']+x} ]]; then
    printf "missing required argument: VALUE\nusage: risks kv set KEY VALUE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_kv_get_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_kv_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="kv get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: risks kv get KEY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_kv_unset_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_kv_unset_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="kv unset"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: risks kv unset KEY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
risks_kv_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_kv_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="kv list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_kv_clean_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_kv_clean_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="kv clean"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
risks_help_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        risks_help_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="help"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['command']+x} ]]; then

          args['command']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  

  # src/initialize.sh

  # Connected terminal
  typeset -H _TTY
  GPG_TTY=$(tty)  # Needed for GPG operations
  export GPG_TTY

  # Remove verbose errors when * don't yield any match in ZSH
  setopt +o nomatch

  # The generated script makes use of BASH_REMATCH, set compat for ZSH
  setopt BASH_REMATCH

  # Use colors unless told not to
  { ! option_is_set --no-color } && { autoload -Uz colors && colors }


  # Don't run as root
  if [[ $EUID -eq 0 ]]; then
      echo "This script must be run as user"
      exit 2
  fi

  # Configuration file -------------------------------------------------------------------------------
  #
  # Directory where risk stores its state
  typeset -rg RISKS_DIR="${HOME}/.risks"

  # Create the risk directory if needed
  [[ -e $RISKS_DIR ]] || { mkdir -p $RISKS_DIR && _info "Creating RISKS directory in $RISKS_DIR" }

  # Write the default configuration if it does not exist.
  config_init

  # Create a symbolic link to the udev rules file we store
  # in the risks directory. This is only done once, when we
  # don't detect our symlink to the /etc/udev/rules.d/hush.rules
  device.link_hush_udev_rules

  # Default filesystem settings from configuration file ----------------------------------------------

  typeset -gr SDCARD_ENC_PART="$(config_get SDCARD_ENC_PART)"
  typeset -gr SDCARD_ENC_PART_MAPPER="$(config_get SDCARD_ENC_PART_MAPPER)"
  typeset -gr SDCARD_QUIET="$(config_get SDCARD_QUIET)"
  typeset -gr BACKUP_MAPPER="$(config_get BACKUP_MAPPER)"
  typeset -gr HUSH_DIR="$(config_get HUSH_DIR)"
  typeset -gr GRAVEYARD="$(config_get GRAVEYARD)"
  typeset -gH GPGPASS_TIMEOUT=$(config_get GPGPASS_TIMEOUT)

  # Default tombs and corresponding mount points (CONSTANTS) .........................................

  typeset -gr GPG_TOMB_LABEL="GPG"          # Stores an identity GPG private keys. Seldom opened
  typeset -gr SSH_TOMB_LABEL="ssh"          # Stores SSH keypairs
  typeset -gr MGMT_TOMB_LABEL="mgmt"        # Holds the key-value store, and anything the user wants.
  typeset -gr PASS_TOMB_LABEL="pass"        # Holds the password store data

  typeset -gr FILE_ENCRYPTION="file_encryption_key" # Simply used as site name in spectre call.

  # Other default security-related default directories/names .........................................

  typeset -gr RAMDISK="${HOME}/.gnupg"

  typeset -gr BACKUP_MOUNT_DIR="/tmp/pendrive"

  typeset -gr DEFAULT_KV_USER_DIR="$HOME/.tomb/mgmt/db/"
  typeset -gr RISKS_SCRIPTS_INSTALL_PATH="${HUSH_DIR}/.risks"

  typeset -gr RISKS_IDENTITY_FILE="${RISKS_DIR}/.identity"

  # Other constants ..................................................................................

  typeset -gr UDEV_RULES_FILE="risks-hush.rules"
  typeset -gr UDEV_RULES_PATH="${RISKS_DIR}/${UDEV_RULES_FILE}" # Contains udev rules for all formatted SDcards

  # Password-store
  export PASSWORD_STORE_ENABLE_EXTENSIONS=true
  export PASSWORD_STORE_GENERATED_LENGTH=20

  # Sensitive & and recurring variables used by program ..............................................

  typeset -gH IDENTITY
  typeset -gH FILE_ENCRYPTION_KEY
  typeset -gH GPG_PASS

}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "hush")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_hush_usage
      else
        risks_hush_command
      fi
      ;;

    "hush format")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_hush_format_usage
      else
        risks_hush_format_command
      fi
      ;;

    "hush mount")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_hush_mount_usage
      else
        risks_hush_mount_command
      fi
      ;;

    "hush rw")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_hush_rw_usage
      else
        risks_hush_rw_command
      fi
      ;;

    "hush ro")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_hush_ro_usage
      else
        risks_hush_ro_command
      fi
      ;;

    "hush umount")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_hush_umount_usage
      else
        risks_hush_umount_command
      fi
      ;;

    "hush status")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_hush_status_usage
      else
        risks_hush_status_command
      fi
      ;;

    "backup")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_backup_usage
      else
        risks_backup_command
      fi
      ;;

    "backup format")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_backup_format_usage
      else
        risks_backup_format_command
      fi
      ;;

    "backup mount")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_backup_mount_usage
      else
        risks_backup_mount_command
      fi
      ;;

    "backup umount")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_backup_umount_usage
      else
        risks_backup_umount_command
      fi
      ;;

    "backup unlock")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_backup_unlock_usage
      else
        risks_backup_unlock_command
      fi
      ;;

    "backup lock")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_backup_lock_usage
      else
        risks_backup_lock_command
      fi
      ;;

    "backup status")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_backup_status_usage
      else
        risks_backup_status_command
      fi
      ;;

    "backup identity")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_backup_identity_usage
      else
        risks_backup_identity_command
      fi
      ;;

    "backup hush")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_backup_hush_usage
      else
        risks_backup_hush_command
      fi
      ;;

    "identity")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_identity_usage
      else
        risks_identity_command
      fi
      ;;

    "identity create")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_identity_create_usage
      else
        risks_identity_create_command
      fi
      ;;

    "identity open")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_identity_open_usage
      else
        risks_identity_open_command
      fi
      ;;

    "identity close")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_identity_close_usage
      else
        risks_identity_close_command
      fi
      ;;

    "identity delete")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_identity_delete_usage
      else
        risks_identity_delete_command
      fi
      ;;

    "identity backup")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_identity_backup_usage
      else
        risks_identity_backup_command
      fi
      ;;

    "identity active")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_identity_active_usage
      else
        risks_identity_active_command
      fi
      ;;

    "gpg")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_gpg_usage
      else
        risks_gpg_command
      fi
      ;;

    "gpg generate")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_gpg_generate_usage
      else
        risks_gpg_generate_command
      fi
      ;;

    "gpg open")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_gpg_open_usage
      else
        risks_gpg_open_command
      fi
      ;;

    "gpg close")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_gpg_close_usage
      else
        risks_gpg_close_command
      fi
      ;;

    "gpg import")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_gpg_import_usage
      else
        risks_gpg_import_command
      fi
      ;;

    "gpg remove")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_gpg_remove_usage
      else
        risks_gpg_remove_command
      fi
      ;;

    "gpg pass")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_gpg_pass_usage
      else
        risks_gpg_pass_command
      fi
      ;;

    "ssh")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_ssh_usage
      else
        risks_ssh_command
      fi
      ;;

    "ssh generate")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_ssh_generate_usage
      else
        risks_ssh_generate_command
      fi
      ;;

    "tomb")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_tomb_usage
      else
        risks_tomb_command
      fi
      ;;

    "tomb create")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_tomb_create_usage
      else
        risks_tomb_create_command
      fi
      ;;

    "tomb open")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_tomb_open_usage
      else
        risks_tomb_open_command
      fi
      ;;

    "tomb close")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_tomb_close_usage
      else
        risks_tomb_close_command
      fi
      ;;

    "tomb delete")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_tomb_delete_usage
      else
        risks_tomb_delete_command
      fi
      ;;

    "list")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_list_usage
      else
        risks_list_command
      fi
      ;;

    "slam")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_slam_usage
      else
        risks_slam_command
      fi
      ;;

    "cleanup")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_cleanup_usage
      else
        risks_cleanup_command
      fi
      ;;

    "load")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_load_usage
      else
        risks_load_command
      fi
      ;;

    "save")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_save_usage
      else
        risks_save_command
      fi
      ;;

    "resolve")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_resolve_usage
      else
        risks_resolve_command
      fi
      ;;

    "resolve coffin")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_resolve_coffin_usage
      else
        risks_resolve_coffin_command
      fi
      ;;

    "resolve tomb")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_resolve_tomb_usage
      else
        risks_resolve_tomb_command
      fi
      ;;

    "resolve key")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_resolve_key_usage
      else
        risks_resolve_key_command
      fi
      ;;

    "config")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_config_usage
      else
        risks_config_command
      fi
      ;;

    "config set")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_config_set_usage
      else
        risks_config_set_command
      fi
      ;;

    "config get")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_config_get_usage
      else
        risks_config_get_command
      fi
      ;;

    "config unset")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_config_unset_usage
      else
        risks_config_unset_command
      fi
      ;;

    "config list")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_config_list_usage
      else
        risks_config_list_command
      fi
      ;;

    "config keys")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_config_keys_usage
      else
        risks_config_keys_command
      fi
      ;;

    "kv")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_kv_usage
      else
        risks_kv_command
      fi
      ;;

    "kv set")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_kv_set_usage
      else
        risks_kv_set_command
      fi
      ;;

    "kv get")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_kv_get_usage
      else
        risks_kv_get_command
      fi
      ;;

    "kv unset")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_kv_unset_usage
      else
        risks_kv_unset_command
      fi
      ;;

    "kv list")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_kv_list_usage
      else
        risks_kv_list_command
      fi
      ;;

    "kv clean")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_kv_clean_usage
      else
        risks_kv_clean_command
      fi
      ;;

    "help")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        risks_help_usage
      else
        risks_help_command
      fi
      ;;

  esac
}

initialize
run "$@"
